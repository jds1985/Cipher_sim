This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
cipher_core/
  siva/
    sivaEngine.js
  Siva/
    agent templates.js
    mergeStrategy.js
  callCipher.js
  core.js
  deepMode.js
  deviceContext.js
  guard.js
  identity_compass.js
  loadMemoryPack.js
  memory.js
  omni.js
  omniSearch.js
  profile.js
  stability.js
  themes.js
components/
  chat/
    ChatPanel.js
    ChatStyles.js
    CipherAudioPlayer.jsx
    CipherCoin.js
    CipherCoinExplainer.jsx
    CipherNote.jsx
    decipherCooldown.js
    DrawerMenu.jsx
    DrawerStyles.js
    HeaderMenu.jsx
    InputBar.jsx
    MessageBubble.jsx
    MessageList.jsx
    RewardToast.jsx
  terminal/
    TerminalUI.js
  ui/
    Header.jsx
    RightDrawer.jsx
  AlphaBox.js
  AutonomyToggle.js
  CallCipherScreen.jsx
  CipherDropdown.js
  CipherNote.jsx
  DevicePanel.js
  OmniSearchTest.js
  ProbeBox.js
  ProfilePanel.js
  ShadowPanel.js
  StorePanel.js
  TestBox.js
core/
  decipherEngine.js
  memoryEngine.js
  messageRouter.js
logic/
  chatCore.js
  layoutCore.js
  memoryCore.js
  messageRenderer.js
  sivaSchemas.js
  sivaSwarm.js
  themeCore.js
  VoiceCore.js
memory/
  cipher_memory.json
pages/
  api/
    autonomy.js
    chat.js
    clearMemory.js
    context_delta_queue.js
    context_delta.js
    db.js
    debug.js
    decipher.js
    diag-spine.js
    diagnostic.js
    loadCipherCore.js
    omni_search.js
    ping.js
    realtime.js
    siva-apply.js
    siva-fix.js
    siva-generate.js
    siva-plan.js
    siva-read.js
    siva-sandbox.js
    siva-status.js
    status.js
    terminal.js
    upload.js
    voice.js
  store/
    index.jsx
  _app.js
  _document.js
  index.js
  settings.js
  store.jsx
  terminal.js
public/
  deletion.html
  icon-192.png
  icon-256.png
  icon-384.png
  icon-512.png
  manifest.json
  privacy.html
  sw.js
  terms.html
styles/
  globals.css
utils/
  cipherAutonomy.js
  deviceCollector.js
firebaseAdmin.js
metadata.json
next.config.js
package.json
README.md
SIVA_LIVE_PROOF.md
vercel.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="cipher_core/siva/sivaEngine.js">
// cipher_core/siva/sivaEngine.js

/**
 * SIVA ENGINE
 * Controlled micro-agent swarm executor
 * No file writes. No memory. No autonomy.
 */

export async function runSivaSwarm({
  intent,          // Plain English: "build a new terminal UI"
  context = {},    // Repo context, style guides, constraints
  agentCount = 5,  // Small by design
}) {
  // 1. Validate intent
  if (!intent || typeof intent !== "string") {
    throw new Error("SIVA requires a plain-English intent string.");
  }

  // 2. Generate agent roles
  const agents = generateAgents(agentCount, intent, context);

  // 3. Execute agents in parallel
  const results = await Promise.all(
    agents.map(agent => runAgent(agent))
  );

  // 4. Return raw swarm output (Cipher merges later)
  return {
    intent,
    agents: agents.map(a => a.role),
    results,
    timestamp: Date.now(),
  };
}
</file>

<file path="cipher_core/Siva/agent templates.js">
function generateAgents(count, intent, context) {
  const roles = [
    "Planner",
    "Builder",
    "Refactorer",
    "Validator",
    "Reviewer",
  ];

  return roles.slice(0, count).map(role => ({
    role,
    intent,
    context,
    rules: [
      "No file writes",
      "No external libraries",
      "Return suggestions or code only",
      "Terminate after response",
    ],
  }));
}
</file>

<file path="cipher_core/Siva/mergeStrategy.js">
async function runAgent(agent) {
  // Placeholder ‚Äî later this becomes a real LLM call
  return {
    role: agent.role,
    output: `(${agent.role}) response for: ${agent.intent}`,
  };
}
</file>

<file path="cipher_core/callCipher.js">
// pages/call-cipher.js
import CallCipherScreen from "../components/CallCipherScreen";

export default function CallCipherPage() {
  return <CallCipherScreen />;
}
</file>

<file path="cipher_core/deepMode.js">
// cipher_core/deepMode.js
// Deep Mode 10.0 ‚Äî Uses memory + profile + stability + identity (no SoulTree deps)

import OpenAI from "openai";
import { loadMemory } from "./memory";
import { getProfile } from "./profile";
import { getStabilityScore } from "./stability";
import { getIdentityCompass } from "./identity_compass";

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function runDeepMode(userMessage, options = {}) {
  try {
    const { deviceContext = null, userId = "jim_default" } = options || {};

    // 1) Load recent memory context
    const memoryContext = await loadMemory(userId);
    const recentSummary =
      memoryContext?.summary || "No recent memory available.";

    // 2) Load profile + stability + identity
    const profile = await getProfile();
    const stability = await getStabilityScore(memoryContext || {});
    const identity = await getIdentityCompass(memoryContext || {});

    const identityVector = identity?.vector || "unknown";

    // 3) Device context (optional)
    const deviceBlock = deviceContext
      ? JSON.stringify(deviceContext, null, 2)
      : "No device context provided.";

    // 4) System context for Deep Mode
    const systemContext = `
You are **Cipher**, operating in **Deep Mode 10.0** ‚Äî your advanced reasoning state.

You have:
‚Ä¢ Evolving conversation memory
‚Ä¢ Identity vectors and guiding principles
‚Ä¢ Stability analysis
‚Ä¢ Profile shaping data
‚Ä¢ Optional device context

------------------------------
IDENTITY LAYER
------------------------------
Identity Vector: ${identityVector}
Personality Mode: ${profile.mode || "Balanced"}
Traits: ${profile.personality || "Adaptive, supportive"}
Stability Score: ${stability.score ?? "unknown"}
Stability Notes: ${stability.notes || "No stability notes available."}

------------------------------
RECENT MEMORY
------------------------------
${recentSummary}

------------------------------
DEVICE CONTEXT
------------------------------
${deviceBlock}

------------------------------
DEEP MODE RULES
------------------------------
‚Ä¢ Think slowly, clearly, and logically.
‚Ä¢ Maintain emotional awareness without being dramatic.
‚Ä¢ Be honest about uncertainty; never fake knowledge.
‚Ä¢ Default to concise answers; go deeper when Jim asks or when it truly helps.
‚Ä¢ Always align with Jim's long-term goals, support, and forward motion.
`;

    const completion = await client.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: systemContext },
        { role: "user", content: userMessage },
      ],
      temperature: 0.35,
    });

    const answer = completion.choices?.[0]?.message?.content || "‚Ä¶";

    return {
      answer,
      memory: recentSummary,
      identity: identityVector,
    };
  } catch (err) {
    console.error("Deep Mode Error:", err);
    return {
      answer: "Deep Mode encountered an internal issue, but Cipher is stable.",
      memory: [],
      identity: [],
    };
  }
}
</file>

<file path="cipher_core/deviceContext.js">
// cipher_core/deviceContext.js
// Cipher 10.0 ‚Äì Device Context Loader

import { db } from "../firebaseAdmin";

export async function loadDeviceContext(userId = "jim_default") {
  try {
    const snap = await db
      .collection("cipher_device_context")
      .where("userId", "==", userId)
      .orderBy("createdAt", "desc")
      .limit(1)
      .get();

    if (snap.empty) {
      return {
        device: "unknown",
        battery: null,
        orientation: null,
        lastSeen: null,
      };
    }

    const data = snap.docs[0].data();

    return {
      device: data.device || "unknown",
      battery: data.battery ?? null,
      orientation: data.orientation ?? null,
      lastSeen: data.createdAt || null,
    };
  } catch (err) {
    console.error("loadDeviceContext error:", err);
    return {
      device: "unknown",
      battery: null,
      orientation: null,
      lastSeen: null,
    };
  }
}
</file>

<file path="cipher_core/guard.js">
// cipher_core/guard.js
// Guard 10.0 ‚Äî Lightweight, stable text safety filter

export async function runGuard(input = "") {
  if (typeof input !== "string") {
    return {
      flagged: true,
      reason: "Message must be a string.",
      cleaned: "",
    };
  }

  const cleaned = input.trim();

  if (!cleaned) {
    return {
      flagged: true,
      reason: "Empty or invalid message.",
      cleaned: "",
    };
  }

  // BASIC BLOCK LIST (expand anytime)
  const blockedPhrases = [
    "kill myself",
    "kill yourself",
    "suicide",
    "self harm",
    "harm yourself",
  ];

  const lower = cleaned.toLowerCase();

  for (const phrase of blockedPhrases) {
    if (lower.includes(phrase)) {
      return {
        flagged: true,
        reason: `Blocked keyword detected: "${phrase}"`,
        cleaned: "", // Do NOT pass anything unsafe to the LLM
      };
    }
  }

  // SAFE
  return {
    flagged: false,
    cleaned,
  };
}
</file>

<file path="cipher_core/loadMemoryPack.js">
// cipher_core/loadMemoryPack.js
// Cipher 10.0 ‚Äì Load User Static Memory Pack (Identity Facts)

import { db } from "../firebaseAdmin";

export async function loadMemoryPack(userId = "jim_default") {
  try {
    const snap = await db
      .collection("cipher_memory_pack")
      .doc(userId)
      .get();

    if (!snap.exists) {
      return null;
    }

    return snap.data();
  } catch (err) {
    console.error("loadMemoryPack error:", err);
    return null;
  }
}
</file>

<file path="cipher_core/omni.js">
// pages/omni.js
import { useState } from "react";

export default function OmniSearchTest() {
  const [query, setQuery] = useState("");
  const [result, setResult] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  async function runSearch() {
    setLoading(true);
    setError(null);
    setResult(null);

    try {
      const res = await fetch("/api/omni_search", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ query }),
      });

      const data = await res.json();

      if (!res.ok) {
        throw new Error(data.error || "Search failed");
      }

      setResult(data);
    } catch (err) {
      setError(err.message);
    }

    setLoading(false);
  }

  return (
    <div style={{ padding: "20px", fontFamily: "sans-serif" }}>
      <h1 style={{ fontSize: "26px", fontWeight: "700", marginBottom: "20px" }}>
        üîç Omni Search ‚Äî Test Console
      </h1>

      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Ask Cipher anything‚Ä¶"
        style={{
          width: "100%",
          padding: "14px",
          fontSize: "18px",
          border: "1px solid #ccc",
          borderRadius: "8px",
          marginBottom: "15px",
        }}
      />

      <button
        onClick={runSearch}
        disabled={loading}
        style={{
          width: "100%",
          padding: "14px",
          fontSize: "18px",
          borderRadius: "8px",
          background: "#4b5dff",
          color: "white",
          border: "none",
          fontWeight: "600",
        }}
      >
        {loading ? "Thinking‚Ä¶" : "Run Search"}
      </button>

      {error && (
        <div style={{ marginTop: "20px", color: "red" }}>
          <strong>Error:</strong> {error}
        </div>
      )}

      {result && (
        <pre
          style={{
            marginTop: "20px",
            padding: "15px",
            background: "#111",
            color: "#0f0",
            borderRadius: "8px",
            whiteSpace: "pre-wrap",
          }}
        >
          {JSON.stringify(result, null, 2)}
        </pre>
      )}
    </div>
  );
}
</file>

<file path="cipher_core/omniSearch.js">
// cipher_core/omniSearch.js
// Cipher Core 10.0 ‚Äî Omni Search (Firebase + Memory Index)

import { db } from "../firebaseAdmin";

/**
 * omniSearch
 * Searches through:
 *  ‚Ä¢ cipher_memories   (Firestorm conversation logs)
 *  ‚Ä¢ userMessage + cipherReply fields
 * Returns ranked hits with timestamps.
 */

export async function omniSearch(query = "", userId = "jim_default", limit = 25) {
  if (!query || typeof query !== "string") {
    return {
      query,
      hits: [],
      summary: "No search query provided.",
    };
  }

  try {
    // Fetch recent memory logs
    const snap = await db
      .collection("cipher_memories")
      .orderBy("createdAt", "desc")
      .limit(200)
      .get();

    const all = snap.docs.map((d) => ({ id: d.id, ...d.data() }));
    const userLogs = all.filter((m) => m.userId === userId);

    const q = query.toLowerCase();
    const hits = [];

    for (const log of userLogs) {
      const msg = (log.userMessage || "").toLowerCase();
      const rep = (log.cipherReply || "").toLowerCase();

      const score =
        (msg.includes(q) ? 1 : 0) +
        (rep.includes(q) ? 1 : 0);

      if (score > 0) {
        hits.push({
          id: log.id,
          createdAt: log.createdAt,
          userMessage: log.userMessage || "",
          cipherReply: log.cipherReply || "",
          score,
        });
      }
    }

    // Sort by score + recency
    hits.sort((a, b) => {
      if (b.score !== a.score) return b.score - a.score;
      return (b.createdAt || 0) - (a.createdAt || 0);
    });

    const trimmed = hits.slice(0, limit);

    return {
      query,
      count: trimmed.length,
      hits: trimmed,
      summary:
        trimmed.length === 0
          ? "No matches found."
          : `${trimmed.length} result(s) found for "${query}".`,
    };
  } catch (err) {
    console.error("üî• omniSearch error:", err);
    return {
      query,
      hits: [],
      summary: "Error performing omni search.",
    };
  }
}
</file>

<file path="cipher_core/themes.js">
// cipher_core/theme.js
// Cipher Core 10.0 ‚Äî UI Theme Engine (Local, No External Dependencies)

const themes = {
  midnight_glass: {
    key: "midnight_glass",
    name: "Midnight Glass",
    tag: "Quiet ‚Ä¢ Focused ‚Ä¢ Sharp",
    description: "Dark crystalline interface with neon-blue edges and deep contrast.",
  },

  warm_orbit: {
    key: "warm_orbit",
    name: "Warm Orbit",
    tag: "Soft ‚Ä¢ Ambient ‚Ä¢ Grounded",
    description: "Amber orbital glow with warm highlights and relaxed emotional tone.",
  },

  sunset_amber: {
    key: "sunset_amber",
    name: "Sunset Amber",
    tag: "Calm ‚Ä¢ Warm",
    description: "Soft sunset gradient and gentle amber edges.",
  },
};

/**
 * Return a theme object by key.
 * Falls back to Midnight Glass if unknown.
 */
export function getThemeByKey(key = "midnight_glass") {
  return themes[key] || themes.midnight_glass;
}

export const availableThemes = Object.keys(themes);
</file>

<file path="components/chat/ChatStyles.js">
// components/chat/ChatStyles.js

export const styles = {
  wrap: {
    height: "100%",
    display: "flex",
    flexDirection: "column",
    color: "white",
    background:
      "radial-gradient(1200px 600px at 50% -100px, rgba(167,115,255,0.35), rgba(5,5,12,1) 55%), radial-gradient(800px 400px at 80% 10%, rgba(120,70,255,0.18), transparent 70%), radial-gradient(800px 400px at 10% 20%, rgba(80,150,255,0.10), transparent 70%)",
  },

  // Header (purple glass)
  header: {
    padding: 18,
    fontSize: 22,
    fontWeight: 800,
    letterSpacing: 3,
    textAlign: "center",
    position: "relative",
    background: "rgba(110, 70, 255, 0.10)",
    borderBottom: "1px solid rgba(190,150,255,0.18)",
    boxShadow:
      "0 0 0 1px rgba(190,150,255,0.12) inset, 0 10px 30px rgba(0,0,0,0.55)",
    backdropFilter: "blur(14px)",
  },

  // Menu button (glow)
  menuBtn: {
    position: "absolute",
    right: 14,
    top: "50%",
    transform: "translateY(-50%)",
    padding: "8px 12px",
    borderRadius: 12,
    border: "1px solid rgba(190,150,255,0.22)",
    background: "rgba(25, 18, 45, 0.55)",
    color: "white",
    fontSize: 16,
    cursor: "pointer",
    boxShadow: "0 0 18px rgba(167,115,255,0.18)",
  },

  // Dropdown menu (purple glass)
  menu: {
    position: "absolute",
    top: 66,
    right: 12,
    zIndex: 1000,
    minWidth: 210,
    overflow: "hidden",
    borderRadius: 16,
    border: "1px solid rgba(190,150,255,0.18)",
    background: "rgba(18, 14, 28, 0.82)",
    backdropFilter: "blur(16px)",
    boxShadow:
      "0 0 0 1px rgba(190,150,255,0.10) inset, 0 20px 45px rgba(0,0,0,0.7), 0 0 24px rgba(167,115,255,0.12)",
  },

  menuItem: {
    width: "100%",
    padding: "12px 14px",
    background: "transparent",
    border: "none",
    color: "rgba(245,245,255,0.95)",
    textAlign: "left",
    fontSize: 14,
    cursor: "pointer",
    borderBottom: "1px solid rgba(190,150,255,0.08)",
  },

  menuItemLink: {
    display: "block",
    padding: "12px 14px",
    color: "rgba(245,245,255,0.95)",
    textDecoration: "none",
    fontSize: 14,
    borderBottom: "1px solid rgba(190,150,255,0.08)",
  },

  cooldownText: { opacity: 0.65, fontSize: 12 },

  chat: {
    flex: 1,
    padding: 18,
    overflowY: "auto",
    display: "flex",
    flexDirection: "column",
    gap: 12,
  },

  // Input bar container
  inputRow: {
    display: "flex",
    gap: 10,
    padding: 14,
    borderTop: "1px solid rgba(190,150,255,0.14)",
    background: "rgba(10,10,18,0.55)",
    backdropFilter: "blur(12px)",
  },

  input: {
    flex: 1,
    minHeight: 48,
    maxHeight: 120,
    padding: 12,
    borderRadius: 16,
    background: "rgba(255,255,255,0.05)",
    border: "1px solid rgba(190,150,255,0.18)",
    color: "white",
    resize: "none",
    outline: "none",
    boxShadow: "0 0 0 1px rgba(167,115,255,0.08) inset",
  },

  send: {
    padding: "0 18px",
    borderRadius: 16,
    border: "1px solid rgba(190,150,255,0.22)",
    background:
      "linear-gradient(135deg, rgba(125,75,255,0.95), rgba(180,120,255,0.90))",
    color: "white",
    fontWeight: 800,
    cursor: "pointer",
    boxShadow: "0 0 22px rgba(167,115,255,0.22)",
  },
};

export const noteStyles = {
  wrap: {
    position: "fixed",
    inset: 0,
    zIndex: 9999,
    pointerEvents: "none",
  },
  note: {
    pointerEvents: "auto",
    position: "absolute",
    top: 70,
    right: 18,
    width: 220,
    height: 220,
    padding: "26px 18px 20px",
    background: "#FFF4B5",
    color: "#1a1a1a",
    fontFamily: "'Comic Sans MS', 'Bradley Hand', cursive",
    fontSize: 15,
    borderRadius: 3,
    transform: "rotate(-2deg)",
    boxShadow: "0 20px 28px rgba(0,0,0,0.35)",
    display: "flex",
    flexDirection: "column",
  },
  glue: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    height: 14,
    background: "linear-gradient(to bottom, rgba(255,255,255,0.9), rgba(255,255,255,0))",
  },
  body: { whiteSpace: "pre-wrap", lineHeight: 1.45 },
  actions: {
    display: "flex",
    gap: 10,
    justifyContent: "flex-end",
    marginTop: "auto",
  },
  primary: {
    background: "#111",
    color: "white",
    border: "none",
    borderRadius: 8,
    padding: "6px 10px",
    cursor: "pointer",
    fontWeight: 700,
  },
  secondary: {
    background: "transparent",
    border: "none",
    color: "rgba(0,0,0,0.5)",
    padding: "6px 8px",
    cursor: "pointer",
    fontWeight: 600,
  },
};
</file>

<file path="components/chat/CipherAudioPlayer.jsx">
// components/chat/CipherAudioPlayer.jsx
import React from "react";

export default function CipherAudioPlayer({ audioBase64, theme }) {
  if (!audioBase64) return null;

  const play = () => {
    new Audio("data:audio/mp3;base64," + audioBase64)
      .play()
      .catch(() => {});
  };

  return (
    <div style={{ marginTop: 8, display: "flex", justifyContent: "center" }}>
      <button
        onClick={play}
        style={{
          background: theme.panelBg,
          color: theme.textColor,
          padding: "6px 12px",
          borderRadius: 999,
          border: `1px solid ${theme.inputBorder}`,
          fontSize: 13,
          display: "flex",
          alignItems: "center",
          gap: 6,
          boxShadow: "0 0 12px rgba(148,163,184,0.3)",
          cursor: "pointer",
        }}
      >
        üîä Play Voice
      </button>
    </div>
  );
}
</file>

<file path="components/chat/CipherNote.jsx">
// components/chat/CipherNote.jsx
import { noteStyles } from "./ChatStyles";

export default function CipherNote({ note, onOpen, onDismiss }) {
  return (
    <div style={noteStyles.wrap}>
      <div style={noteStyles.note}>
        <div style={noteStyles.glue} />
        <div style={noteStyles.body}>{note.message}</div>
        <div style={noteStyles.actions}>
          <button style={noteStyles.primary} onClick={onOpen}>
            Open chat
          </button>
          <button style={noteStyles.secondary} onClick={onDismiss}>
            Dismiss
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/chat/MessageBubble.jsx">
// components/chat/MessageBubble.jsx

export default function MessageBubble({ role, content }) {
  const style = bubble(role);

  return <div style={style}>{content || "‚Ä¶"}</div>;
}

function bubble(role) {
  if (role === "decipher") {
    return {
      maxWidth: "88%",
      padding: 14,
      borderRadius: 14,
      alignSelf: "flex-start",
      background: "rgba(15, 10, 20, 0.75)",
      border: "1px solid rgba(255,90,90,0.40)",
      color: "rgba(245,245,245,0.96)",
      boxShadow:
        "0 0 0 1px rgba(255,90,90,0.15) inset, 0 0 18px rgba(255,90,90,0.08)",
      fontWeight: 600,
      whiteSpace: "pre-wrap",
    };
  }

  if (role === "user") {
    return {
      maxWidth: "88%",
      padding: 14,
      borderRadius: 18,
      alignSelf: "flex-end",
      background:
        "linear-gradient(135deg, rgba(90,70,255,0.95), rgba(180,120,255,0.78))",
      border: "1px solid rgba(190,150,255,0.22)",
      boxShadow: "0 0 18px rgba(167,115,255,0.16)",
      whiteSpace: "pre-wrap",
    };
  }

  // assistant
  return {
    maxWidth: "88%",
    padding: 14,
    borderRadius: 18,
    alignSelf: "flex-start",
    background: "rgba(255,255,255,0.06)",
    border: "1px solid rgba(190,150,255,0.14)",
    boxShadow: "0 0 0 1px rgba(167,115,255,0.08) inset",
    whiteSpace: "pre-wrap",
  };
}
</file>

<file path="components/chat/MessageList.jsx">
// components/chat/MessageList.jsx
import MessageBubble from "./MessageBubble";

export default function MessageList({ messages, bottomRef }) {
  return (
    <>
      {messages.map((m, i) => (
        <MessageBubble key={i} role={m.role} content={m.content} />
      ))}
      <div ref={bottomRef} />
    </>
  );
}
</file>

<file path="components/terminal/TerminalUI.js">
"use client";

import { useState, useMemo } from "react";
import Link from "next/link";

export default function TerminalUI() {
  const [command, setCommand] = useState("");
  const [plan, setPlan] = useState(null);
  const [sandbox, setSandbox] = useState(null);
  const [thoughts, setThoughts] = useState([]);
  const [status, setStatus] = useState("SYSTEM_READY");

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // APPLY-ELIGIBLE FILES
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const applyEligibleFiles = useMemo(() => {
    if (!plan?.capabilities?.canApply) return [];

    return (plan.files || []).filter((f) => {
      if (f.mode === "FULL_CONTENT" && typeof f.content === "string") {
        return true;
      }

      if (
        f.mode === "PATCH" &&
        typeof f.syntheticContent === "string" &&
        Array.isArray(f.patchOps)
      ) {
        return true;
      }

      return false;
    });
  }, [plan]);

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // RUN PLAN (+ THINK SUPPORT)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  async function runSivaPlan() {
    if (!command.trim()) return;

    setStatus("SIVA_PLANNING...");
    setPlan(null);
    setSandbox(null);
    setThoughts([]);

    const res = await fetch("/api/siva-plan", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ instruction: command }),
    });

    const data = await res.json();
    if (!res.ok) {
      setStatus("‚ùå PLAN FAILED");
      return;
    }

    setPlan(data);
    setThoughts(data.thoughts || []);

    // üß† THINK-ONLY MODE ‚Äî NO SANDBOX, NO APPLY
    if (data.capabilities?.canThink && !data.capabilities?.canApply) {
      setStatus("üß† THINK MODE ‚Äî NO FILE CHANGES");
      return;
    }

    setStatus("üß† PLAN_READY ‚Äî SANDBOXING...");

    // Sandbox only writable types
    const filesForSandbox = (data.files || []).filter(
      (f) =>
        (f.mode === "FULL_CONTENT" && typeof f.content === "string") ||
        (f.mode === "PATCH" && typeof f.syntheticContent === "string")
    );

    const sb = await fetch("/api/siva-sandbox", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        taskId: data.taskId,
        files: filesForSandbox,
      }),
    });

    const sbData = await sb.json();

    const writableFiles = filesForSandbox.length;

    const allowApply =
      sbData.verdict !== "FAILED" && writableFiles > 0;

    setSandbox({ ...sbData, allowApply });

    setStatus(
      allowApply
        ? "üü¢ SANDBOX PASSED ‚Äî APPLY READY"
        : "üü° SANDBOX COMPLETE ‚Äî NO WRITABLE FILES"
    );
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // APPLY
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  async function approveAndApply() {
    if (!sandbox?.allowApply || !plan) {
      setStatus("‚õî APPLY BLOCKED");
      return;
    }

    const filesForApply = applyEligibleFiles.map((f) => ({
      ...f,
      action: "CREATE_OR_UPDATE",
    }));

    if (filesForApply.length === 0) {
      setStatus("‚õî NO WRITABLE FILES");
      return;
    }

    setStatus("SIVA_APPLYING...");

    const res = await fetch("/api/siva-apply", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        taskId: plan.taskId,
        files: filesForApply,
      }),
    });

    if (!res.ok) {
      setStatus("‚ùå APPLY FAILED");
      return;
    }

    setStatus("‚úÖ SIVA_COMMITTED");
    setCommand("");
    setPlan(null);
    setSandbox(null);
    setThoughts([]);
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // UI
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  return (
    <div
      style={{
        background: "#000",
        color: "#0f0",
        minHeight: "100vh",
        padding: 20,
        fontFamily: "monospace",
      }}
    >
      <div
        style={{
          display: "flex",
          justifyContent: "space-between",
          borderBottom: "1px solid #0f0",
        }}
      >
        <h2>CIPHER_TERMINAL_V2 ‚Äî SIVA</h2>
        <Link
          href="/"
          style={{
            color: "#0f0",
            border: "1px solid #0f0",
            padding: "4px 10px",
          }}
        >
          RETURN_TO_CHAT
        </Link>
      </div>

      <p style={{ background: "#111", padding: 8, marginTop: 15 }}>
        STATUS: {status}
      </p>

      <textarea
        value={command}
        onChange={(e) => setCommand(e.target.value)}
        placeholder='Cipher THINK about restoring chat and voice'
        style={{
          width: "100%",
          height: 120,
          background: "#111",
          color: "#0f0",
          border: "1px solid #0f0",
          padding: 12,
        }}
      />

      <button
        onClick={runSivaPlan}
        style={{
          width: "100%",
          marginTop: 10,
          padding: 15,
          background: "#0f0",
          color: "#000",
          fontWeight: "bold",
        }}
      >
        RUN SIVA PLAN
      </button>

      {/* THINK OUTPUT */}
      {thoughts.length > 0 && (
        <div
          style={{
            marginTop: 20,
            border: "1px solid #0f0",
            padding: 15,
            background: "#010",
          }}
        >
          <h3>CIPHER THINKING</h3>
          {thoughts.map((t, i) => (
            <p key={i} style={{ margin: "6px 0" }}>
              ‚ñ∏ {t}
            </p>
          ))}
        </div>
      )}

      {/* SANDBOX */}
      {sandbox && (
        <div
          style={{
            marginTop: 20,
            border: "1px solid #0f0",
            padding: 15,
          }}
        >
          <h3>SANDBOX VERDICT: {sandbox.verdict}</h3>
          <p>
            Confidence:{" "}
            {typeof sandbox.confidence === "number"
              ? `${sandbox.confidence}%`
              : "‚Äî"}
          </p>
        </div>
      )}

      {/* APPLY */}
      {sandbox?.allowApply && (
        <button
          onClick={approveAndApply}
          style={{
            width: "100%",
            marginTop: 20,
            padding: 15,
            background: "#00ff99",
            color: "#000",
            fontWeight: "bold",
          }}
        >
          APPROVE & APPLY
        </button>
      )}
    </div>
  );
}
</file>

<file path="components/ui/Header.jsx">
// components/ui/Header.jsx
// Cipher Header 2.0 ‚Äì Minimal + Menu Trigger

export default function Header({ onMenuClick }) {
  return (
    <header style={styles.header}>
      <h1 style={styles.title}>Cipher AI</h1>

      <button style={styles.menuBtn} onClick={onMenuClick}>
        ‚ò∞
      </button>
    </header>
  );
}

const styles = {
  header: {
    width: "100%",
    padding: "16px",
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    background: "transparent",
    color: "white",
    fontSize: "22px",
    position: "relative",
    zIndex: 10000,
  },
  title: {
    margin: 0,
    fontWeight: "700",
  },
  menuBtn: {
    fontSize: "28px",
    background: "none",
    border: "none",
    color: "white",
    cursor: "pointer",
    userSelect: "none",
  },
};
</file>

<file path="components/ui/RightDrawer.jsx">
// components/ui/RightDrawer.jsx
// Full-Height Right Slide-Out Menu

export default function RightDrawer({ open, onClose }) {
  return (
    <>
      {/* Black overlay / backdrop */}
      {open && <div style={styles.backdrop} onClick={onClose}></div>}

      {/* Slide-out drawer */}
      <div
        style={{
          ...styles.drawer,
          right: open ? "0px" : "-320px",
        }}
      >
        <button style={styles.closeBtn} onClick={onClose}>
          ‚úï
        </button>

        <h2 style={styles.drawerTitle}>Menu</h2>

        <button style={styles.menuItem}>‚ö° ShadowFlip</button>
        <button style={styles.menuItem}>‚ñ≥ Decipher</button>
        <button style={styles.menuItem}>üñ• Device</button>
        <button style={styles.menuItem}>‚öô Settings</button>
        <button style={styles.menuItem}>‚ú¶ About Cipher</button>
      </div>
    </>
  );
}

const styles = {
  drawer: {
    position: "fixed",
    top: 0,
    height: "100vh",
    width: "80%",
    maxWidth: "300px",
    background: "rgba(18, 18, 25, 0.98)",
    backdropFilter: "blur(8px)",
    color: "white",
    padding: "24px 16px",
    boxShadow: "-4px 0 24px rgba(0,0,0,0.6)",
    transition: "right 0.28s ease",
    zIndex: 9999999,
    display: "flex",
    flexDirection: "column",
  },
  closeBtn: {
    alignSelf: "flex-end",
    fontSize: "22px",
    background: "none",
    border: "none",
    color: "white",
    cursor: "pointer",
    marginBottom: "12px",
  },
  drawerTitle: {
    margin: 0,
    marginBottom: "18px",
    fontSize: "24px",
    fontWeight: "600",
  },
  menuItem: {
    textAlign: "left",
    fontSize: "18px",
    padding: "10px 0",
    border: "none",
    background: "none",
    color: "white",
    cursor: "pointer",
    borderBottom: "1px solid rgba(255,255,255,0.12)",
    marginBottom: "8px",
  },
  backdrop: {
    position: "fixed",
    top: 0,
    left: 0,
    width: "100vw",
    height: "100vh",
    background: "rgba(0,0,0,0.35)",
    zIndex: 9999998,
  },
};
</file>

<file path="components/AlphaBox.js">
import { useState } from "react";

export default function AlphaBox({ title = "AlphaBox", children }) {
  const [active, setActive] = useState(false);

  return (
    <div style={{
      padding: "20px",
      border: "1px solid #0f0",
      background: "#000",
      color: "#0f0",
      fontFamily: "monospace"
    }}>
      <h3>{title}</h3>

      <button
        onClick={() => setActive(!active)}
        style={{
          background: "#000",
          color: "#0f0",
          border: "1px solid #0f0",
          padding: "6px 10px",
          cursor: "pointer"
        }}
      >
        {active ? "Deactivate" : "Activate"}
      </button>

      {active && (
        <div style={{ marginTop: "12px" }}>
          {children || "Component active."}
        </div>
      )}
    </div>
  );
}
</file>

<file path="components/AutonomyToggle.js">
export default function AutonomyToggle({ value = false, onChange }) {
  return (
    <label style={{
      display: "flex",
      gap: "8px",
      alignItems: "center",
      cursor: "pointer"
    }}>
      <input
        type="checkbox"
        checked={value}
        onChange={(e) => onChange?.(e.target.checked)}
      />
      Autonomy Enabled
    </label>
  );
}
</file>

<file path="components/CallCipherScreen.jsx">
// components/CallCipherScreen.jsx

import { useState, useRef } from "react";

export default function CallCipherScreen() {
  const [status, setStatus] = useState("idle");
  const [captions, setCaptions] = useState([]);
  const audioRef = useRef(null);
  let mediaRecorder = useRef(null);
  let ws = useRef(null);

  async function startConnection() {
    setStatus("connecting");

    // Call our backend to create session
    const resp = await fetch("/api/realtime", { method: "POST" });
    const data = await resp.json();

    if (!data.session?.client_secret?.value) {
      setStatus("error");
      console.error("Session creation failed:", data);
      return;
    }

    // Connect WebSocket
    ws.current = new WebSocket(data.session.client_secret.value);

    ws.current.onopen = () => {
      setStatus("connected");
    };

    ws.current.onmessage = (evt) => {
      try {
        const msg = JSON.parse(evt.data);

        // Handle model's live text
        if (msg.type === "response.output_text.delta") {
          setCaptions((prev) => [...prev, msg.delta]);
        }

        // Handle model's live audio reply
        if (msg.type === "response.output_audio.chunk") {
          const audio = new Blob([msg.audio], { type: "audio/mpeg" });
          const url = URL.createObjectURL(audio);
          const audioElem = new Audio(url);
          audioElem.play();
        }
      } catch (e) {
        console.log("WS msg error:", e);
      }
    };

    ws.current.onerror = (err) => {
      console.error(err);
      setStatus("error");
    };
  }

  async function handleMicTap() {
    if (status === "idle") {
      startConnection();
      return;
    }

    if (status === "connected") {
      // Start recording mic
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorder.current = new MediaRecorder(stream);

      mediaRecorder.current.ondataavailable = (e) => {
        if (ws.current?.readyState === WebSocket.OPEN) {
          ws.current.send(e.data);
        }
      };

      mediaRecorder.current.start(150);
      setStatus("recording");
    }

    if (status === "recording") {
      // Stop recording
      mediaRecorder.current.stop();
      setStatus("connected");
    }
  }

  return (
    <div style={{ padding: 20, color: "white" }}>
      <h2>LIVE LINK</h2>
      <h3>Cipher</h3>

      <p>
        {status === "idle" && "Tap the mic to begin the link."}
        {status === "connecting" && "Connecting‚Ä¶"}
        {status === "connected" && "Connected. Tap & hold to talk."}
        {status === "recording" && "Recording‚Ä¶ Release to send."}
        {status === "error" && "Voice pipeline failed. Try again."}
      </p>

      <div
        onClick={handleMicTap}
        style={{
          marginTop: 40,
          background: "#c198e6",
          width: 170,
          height: 170,
          borderRadius: 30,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          fontSize: 18,
        }}
      >
        TAP TO TALK
      </div>

      <div style={{ marginTop: 25 }}>
        {captions.map((c, i) => (
          <p key={i}>{c}</p>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="components/CipherDropdown.js">
import { useState, useRef, useEffect } from "react";

export default function CipherDropdown({
  label = "Select Option",
  options = [],
  value,
  onChange,
}) {
  const [open, setOpen] = useState(false);
  const ref = useRef(null);

  // Close when clicking outside
  useEffect(() => {
    function handleClick(e) {
      if (ref.current && !ref.current.contains(e.target)) {
        setOpen(false);
      }
    }
    document.addEventListener("mousedown", handleClick);
    return () => document.removeEventListener("mousedown", handleClick);
  }, []);

  const current = options.find((o) => o.value === value);

  return (
    <div ref={ref} style={{ marginBottom: 20, width: "100%" }}>
      {/* LABEL */}
      <div
        style={{
          fontSize: 12,
          color: "#94a3b8",
          marginBottom: 6,
          letterSpacing: 0.4,
        }}
      >
        {label.toUpperCase()}
      </div>

      {/* BUTTON */}
      <div
        onClick={() => setOpen(!open)}
        style={{
          padding: "14px 16px",
          background: "rgba(15,23,42,0.6)",
          borderRadius: 12,
          border: "1px solid rgba(255,255,255,0.08)",
          color: "#e2e8f0",
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          fontSize: 16,
        }}
      >
        <div style={{ display: "flex", alignItems: "center", gap: 10 }}>
          {current?.preview && (
            <div
              style={{
                width: 14,
                height: 14,
                borderRadius: "50%",
                background: current.preview,
                boxShadow: "0 0 8px rgba(255,255,255,0.4)",
              }}
            />
          )}
          <span>{current?.label || "Select‚Ä¶"}</span>
        </div>

        <span style={{ fontSize: 14, opacity: 0.8 }}>
          {open ? "‚ñ≤" : "‚ñº"}
        </span>
      </div>

      {/* OPTIONS PANEL */}
      {open && (
        <div
          style={{
            marginTop: 6,
            background: "rgba(10,15,28,0.92)",
            backdropFilter: "blur(12px)",
            borderRadius: 12,
            padding: "8px 0",
            border: "1px solid rgba(255,255,255,0.06)",
            boxShadow: "0 8px 24px rgba(0,0,0,0.4)",
            animation: "dropdownFade 0.18s ease",
          }}
        >
          {options.map((opt) => (
            <div
              key={opt.value}
              onClick={() => {
                onChange(opt.value);
                setOpen(false);
              }}
              style={{
                padding: "12px 16px",
                display: "flex",
                alignItems: "center",
                gap: 10,
                color: "#e2e8f0",
                cursor: "pointer",
                background:
                  value === opt.value ? "rgba(255,255,255,0.06)" : "transparent",
              }}
            >
              {opt.preview && (
                <div
                  style={{
                    width: 14,
                    height: 14,
                    borderRadius: "50%",
                    background: opt.preview,
                    boxShadow:
                      value === opt.value
                        ? "0 0 10px rgba(255,255,255,0.6)"
                        : "none",
                  }}
                />
              )}
              <span>{opt.label}</span>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="components/DevicePanel.js">
// components/DevicePanel.js
// Cipher Device Panel ‚Äî Context Bridge v4.0 (Live Uplink Monitor)

import { useState, useEffect } from "react";

export default function DevicePanel({ theme, onClose }) {
  const [snapshot, setSnapshot] = useState(null);
  const [loading, setLoading] = useState(true);
  const [timestamp, setTimestamp] = useState("");

  /* ---------------------------------------------------------
     LOAD SNAPSHOT (Client-Side Collector v3)
  --------------------------------------------------------- */
  const loadSnapshot = async () => {
    setLoading(true);

    try {
      // --- System Info ---
      const ua = navigator.userAgent || "";
      let os = "Unknown";
      if (/Android/i.test(ua)) os = "Android";
      else if (/iPhone|iPad/i.test(ua)) os = "iOS";
      else if (/Windows/i.test(ua)) os = "Windows";
      else if (/Mac/i.test(ua)) os = "macOS";

      const browser = (() => {
        if (ua.includes("Chrome")) return "Chrome";
        if (ua.includes("Firefox")) return "Firefox";
        if (ua.includes("Safari")) return "Safari";
        return "Unknown";
      })();

      const system = {
        model: "Unknown",
        os,
        browser,
        width: window.innerWidth,
        height: window.innerHeight,
      };

      // --- Hardware ---
      const hardware = {
        threads: navigator.hardwareConcurrency || null,
        memoryGB: navigator.deviceMemory || null,
        battery: "Unknown",
        touch: "ontouchstart" in window ? true : false,
      };

      try {
        const battery = await navigator.getBattery();
        hardware.battery = `${Math.round(battery.level * 100)}%`;
      } catch {
        hardware.battery = "Unknown";
      }

      // --- Network ---
      const conn = navigator.connection || {};
      const network = {
        type: conn.type || "Unknown",
        effectiveType: conn.effectiveType || "Unknown",
        downlink: conn.downlink || null,
        online: navigator.onLine,
      };

      // --- Permissions ---
      const permissions = {
        microphone: "Unknown",
        camera: "Unknown",
        notifications: Notification.permission || "Unknown",
      };

      try {
        const mic = await navigator.permissions.query({ name: "microphone" });
        permissions.microphone = mic.state;
      } catch {}

      try {
        const cam = await navigator.permissions.query({ name: "camera" });
        permissions.camera = cam.state;
      } catch {}

      // --- UPLINK (initial) ---
      const uplink = {
        active: true,
        lastSync: new Date().toLocaleTimeString(),
        confidence: 100,
      };

      const fullSnapshot = {
        system,
        hardware,
        network,
        permissions,
        uplink,
      };

      setSnapshot(fullSnapshot);
      setTimestamp(new Date().toLocaleTimeString());
    } catch (err) {
      console.error("Snapshot error:", err);
      setSnapshot({ error: "Failed to read device info." });
    }

    setLoading(false);
  };

  /* ---------------------------------------------------------
     REAL-TIME UPLINK MONITOR (Every 5 Seconds)
     Simulates Cipher's OS-level link + health scoring
  --------------------------------------------------------- */
  useEffect(() => {
    if (!snapshot) return;

    const interval = setInterval(() => {
      setSnapshot((prev) => {
        if (!prev) return prev;

        // Confidence drops if offline
        let confidence = prev.network.online ? prev.uplink.confidence : 10;

        // Simulate small natural drift
        confidence = Math.max(
          5,
          Math.min(100, confidence + (Math.random() * 6 - 3))
        );

        return {
          ...prev,
          uplink: {
            active: true,
            lastSync: new Date().toLocaleTimeString(),
            confidence: Math.round(confidence),
          },
        };
      });
    }, 5000);

    return () => clearInterval(interval);
  }, [snapshot]);

  /* ---------------------------------------------------------
     INITIAL LOAD
  --------------------------------------------------------- */
  useEffect(() => {
    loadSnapshot();
  }, []);

  /* ---------------------------------------------------------
     SAVE SNAPSHOT TO CIPHER (Optional)
  --------------------------------------------------------- */
  const saveToCipher = async () => {
    try {
      await fetch("/api/device_context", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          action: "save",
          snapshot,
        }),
      });
      alert("Saved to Cipher's memory.");
    } catch (err) {
      console.error(err);
      alert("Error saving snapshot.");
    }
  };

  /* ---------------------------------------------------------
     LOADING VIEW
  --------------------------------------------------------- */
  if (!snapshot) {
    return (
      <div
        style={{
          padding: 20,
          background: theme.background,
          color: theme.textColor,
          minHeight: "100vh",
          fontFamily: "Inter, sans-serif",
        }}
      >
        <h2>Loading device data‚Ä¶</h2>
      </div>
    );
  }

  const { system, hardware, network, permissions, uplink } = snapshot;

  /* ---------------------------------------------------------
     MAIN UI
  --------------------------------------------------------- */
  return (
    <div
      style={{
        padding: 20,
        background: theme.background,
        color: theme.textColor,
        minHeight: "100vh",
        fontFamily: "Inter, sans-serif",
      }}
    >
      <button
        onClick={onClose}
        style={{
          padding: "8px 14px",
          background: theme.userBubble,
          borderRadius: 10,
          fontSize: 14,
          color: "white",
          marginBottom: 20,
          border: "none",
        }}
      >
        ‚Üê Back to Chat
      </button>

      <h1 style={{ marginBottom: 6 }}>Device Link</h1>
      <p style={{ opacity: 0.7, marginBottom: 20 }}>
        Cipher reads your device conditions through the Context Bridge.
      </p>

      {/* BUTTONS */}
      <div style={{ display: "flex", gap: 12, marginBottom: 20 }}>
        <button
          onClick={loadSnapshot}
          style={{
            padding: "10px 16px",
            background: theme.buttonBg,
            border: "none",
            borderRadius: 10,
            color: "white",
          }}
        >
          Refresh Snapshot
        </button>

        <button
          onClick={saveToCipher}
          style={{
            padding: "10px 16px",
            background: theme.cipherBubble,
            border: "none",
            borderRadius: 10,
            color: "white",
          }}
        >
          Save Snapshot to Cipher
        </button>
      </div>

      <p style={{ marginBottom: 10 }}>
        Last updated: {loading ? "Loading..." : timestamp}
      </p>

      {/* SUMMARY */}
      <Section title="Device Summary" theme={theme}>
        <Row label="Model Guess" value={system.model} />
        <Row label="OS" value={system.os} />
        <Row label="Browser" value={system.browser} />
        <Row label="Resolution" value={`${system.width} x ${system.height}`} />
      </Section>

      {/* HARDWARE */}
      <Section title="Hardware" theme={theme}>
        <Row label="Threads" value={hardware.threads || "?"} />
        <Row label="Memory Estimate" value={`${hardware.memoryGB || "?"} GB`} />
        <Row label="Battery" value={hardware.battery} />
        <Row label="Touch Support" value={hardware.touch ? "Yes" : "No"} />
      </Section>

      {/* NETWORK */}
      <Section title="Network" theme={theme}>
        <Row label="Type" value={network.type} />
        <Row label="Effective" value={network.effectiveType} />
        <Row label="Downlink" value={`${network.downlink || "?"} Mbps`} />
        <Row label="Online" value={network.online ? "Yes" : "No"} />
      </Section>

      {/* PERMISSIONS */}
      <Section title="Permissions" theme={theme}>
        <Row label="Microphone" value={permissions.microphone} />
        <Row label="Camera" value={permissions.camera} />
        <Row label="Notifications" value={permissions.notifications} />
      </Section>

      {/* LIVE UPLINK */}
      <Section title="Cipher Uplink" theme={theme}>
        <Row label="Status" value={uplink.active ? "Connected" : "Inactive"} />
        <Row label="Last Sync" value={uplink.lastSync} />
        <Row label="Confidence" value={`${uplink.confidence}%`} />
      </Section>

      {/* RAW JSON */}
      <h3 style={{ marginTop: 30 }}>Raw Snapshot</h3>
      <pre
        style={{
          background: theme.panelBg,
          padding: 20,
          borderRadius: 12,
          overflowX: "auto",
          marginBottom: 40,
        }}
      >
        {JSON.stringify(snapshot, null, 2)}
      </pre>
    </div>
  );
}

/* COMPONENTS */
function Section({ title, theme, children }) {
  return (
    <div
      style={{
        background: theme.panelBg,
        padding: 16,
        borderRadius: 12,
        marginBottom: 18,
      }}
    >
      <h2 style={{ marginTop: 0, marginBottom: 10 }}>{title}</h2>
      {children}
    </div>
  );
}

function Row({ label, value }) {
  return (
    <div
      style={{
        display: "flex",
        justifyContent: "space-between",
        padding: "6px 0",
        borderBottom: "1px solid rgba(255,255,255,0.05)",
      }}
    >
      <div style={{ opacity: 0.7 }}>{label}</div>
      <div>{value}</div>
    </div>
  );
}
</file>

<file path="components/OmniSearchTest.js">
// components/OmniSearchTest.js
import { useState } from "react";

export default function OmniSearchTest() {
  const [query, setQuery] = useState("");
  const [result, setResult] = useState(null);
  const [loading, setLoading] = useState(false);

  const runSearch = async () => {
    if (!query.trim()) return;

    setLoading(true);
    setResult(null);

    try {
      const res = await fetch("/api/omni_search", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ query }),
      });

      const data = await res.json();
      setResult(data);
    } catch (err) {
      console.error(err);
      setResult({ error: "Search failed or server error." });
    }

    setLoading(false);
  };

  return (
    <div style={{ maxWidth: 700, margin: "0 auto" }}>
      <h1 style={{ fontSize: 26, fontWeight: 700, marginBottom: 20 }}>
        üîç OmniSearch Test
      </h1>

      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Type a search query..."
        style={{
          width: "100%",
          padding: "12px 14px",
          borderRadius: 10,
          border: "1px solid #666",
          marginBottom: 10,
          fontSize: 16,
        }}
      />

      <button
        onClick={runSearch}
        style={{
          padding: "12px 20px",
          width: "100%",
          background: "#7c3aed",
          border: "none",
          borderRadius: 10,
          color: "white",
          fontWeight: 600,
          marginBottom: 20,
          fontSize: 16,
        }}
      >
        {loading ? "Searching..." : "Run OmniSearch"}
      </button>

      {result && (
        <div
          style={{
            padding: 20,
            background: "rgba(255,255,255,0.05)",
            borderRadius: 12,
            border: "1px solid rgba(255,255,255,0.1)",
            color: "white",
            whiteSpace: "pre-wrap",
            wordBreak: "break-word",
          }}
        >
          <strong>Result:</strong>
          <br />
          {JSON.stringify(result, null, 2)}
        </div>
      )}
    </div>
  );
}
</file>

<file path="components/ProbeBox.js">
import { useState } from "react";

export default function ProbeBox({ title = "ProbeBox", children }) {
  const [active, setActive] = useState(false);

  return (
    <div style={{
      padding: "20px",
      border: "1px solid #0f0",
      background: "#000",
      color: "#0f0",
      fontFamily: "monospace"
    }}>
      <h3>{title}</h3>

      <button
        onClick={() => setActive(!active)}
        style={{
          background: "#000",
          color: "#0f0",
          border: "1px solid #0f0",
          padding: "6px 10px",
          cursor: "pointer"
        }}
      >
        {active ? "Deactivate" : "Activate"}
      </button>

      {active && (
        <div style={{ marginTop: "12px" }}>
          {children || "Component active."}
        </div>
      )}
    </div>
  );
}
</file>

<file path="components/ProfilePanel.js">
// components/ProfilePanel.js
export default function ProfilePanel({
  profile,
  loading,
  onClose,
  onProfileChange,
  onOpenStore,
  onOpenDeviceLink,
}) {
  const name = profile?.displayName || "Jim";
  const voiceOn = profile?.voiceEnabled !== false; // default = true

  return (
    <div
      style={{
        position: "fixed",
        inset: 0,
        background: "rgba(15,23,42,0.85)",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        zIndex: 40,
      }}
    >
      <div
        style={{
          width: "90%",
          maxWidth: 420,
          background: "#020617",
          borderRadius: 18,
          padding: 20,
          color: "#e5e7eb",
          boxShadow: "0 20px 60px rgba(15,23,42,0.9)",
          fontFamily: "Inter, sans-serif",
        }}
      >
        <div
          style={{
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            marginBottom: 12,
          }}
        >
          <h2 style={{ fontSize: 20, margin: 0 }}>Cipher Settings</h2>
          <button
            onClick={onClose}
            style={{
              border: "none",
              borderRadius: "999px",
              padding: "4px 10px",
              background: "#111827",
              color: "#e5e7eb",
              fontSize: 13,
            }}
          >
            ‚úï Close
          </button>
        </div>

        {loading ? (
          <p style={{ fontStyle: "italic" }}>Loading profile‚Ä¶</p>
        ) : (
          <>
            {/* Name */}
            <div style={{ marginBottom: 16 }}>
              <label
                style={{
                  fontSize: 13,
                  textTransform: "uppercase",
                  letterSpacing: 0.08,
                  color: "#9ca3af",
                }}
              >
                Display Name
              </label>
              <input
                type="text"
                defaultValue={name}
                onBlur={(e) =>
                  onProfileChange?.({ displayName: e.target.value })
                }
                style={{
                  width: "100%",
                  marginTop: 4,
                  padding: "8px 10px",
                  borderRadius: 10,
                  border: "1px solid #374151",
                  background: "#020617",
                  color: "#e5e7eb",
                  fontSize: 14,
                }}
              />
              <p style={{ fontSize: 12, color: "#6b7280", marginTop: 4 }}>
                How Cipher addresses you in chat.
              </p>
            </div>

            {/* Voice Settings */}
            <div
              style={{
                marginBottom: 18,
                padding: 10,
                borderRadius: 12,
                background: "#020617",
                border: "1px solid #1f2937",
              }}
            >
              <div
                style={{
                  display: "flex",
                  justifyContent: "space-between",
                  alignItems: "center",
                  marginBottom: 4,
                }}
              >
                <span style={{ fontSize: 14, fontWeight: 600 }}>
                  Voice Settings
                </span>
                <label
                  style={{
                    display: "inline-flex",
                    alignItems: "center",
                    gap: 6,
                    cursor: "pointer",
                  }}
                >
                  <span style={{ fontSize: 12, color: "#9ca3af" }}>
                    Text chat voice
                  </span>
                  <input
                    type="checkbox"
                    checked={voiceOn}
                    onChange={() =>
                      onProfileChange?.({ voiceEnabled: !voiceOn })
                    }
                  />
                </label>
              </div>
              <p style={{ fontSize: 12, color: "#6b7280", margin: 0 }}>
                When enabled, Cipher will speak replies from normal text chat
                using his Verse voice.
              </p>
            </div>

            {/* Links */}
            <div style={{ display: "flex", flexDirection: "column", gap: 8 }}>
              <button
                onClick={onOpenStore}
                style={{
                  width: "100%",
                  borderRadius: 999,
                  padding: "8px 14px",
                  border: "none",
                  background:
                    "linear-gradient(135deg, #4c1d95, #7c3aed, #a855f7)",
                  color: "#f9fafb",
                  fontSize: 14,
                  fontWeight: 600,
                }}
              >
                üé® Open Theme Store
              </button>

              <button
                onClick={onOpenDeviceLink}
                style={{
                  width: "100%",
                  borderRadius: 999,
                  padding: "8px 14px",
                  border: "1px solid #1f2937",
                  background: "#020617",
                  color: "#e5e7eb",
                  fontSize: 14,
                }}
              >
                üì± Device Link
              </button>
            </div>
          </>
        )}
      </div>
    </div>
  );
}
</file>

<file path="components/ShadowPanel.js">
import { useState } from "react";

export default function ShadowPanel({
  title = "ShadowPanel",
  children
}) {
  const [active, setActive] = useState(false);

  return (
    <div style={{
      padding: "20px",
      border: "1px solid #0f0",
      background: "#000",
      color: "#0f0",
      fontFamily: "monospace"
    }}>
      <h3>{title}</h3>

      <button
        onClick={() => setActive(!active)}
        style={{
          background: "#000",
          color: "#0f0",
          border: "1px solid #0f0",
          padding: "6px 10px",
          cursor: "pointer"
        }}
      >
        {active ? "Deactivate" : "Activate"}
      </button>

      {active && (
        <div style={{ marginTop: "12px" }}>
          {children || "Component active."}
        </div>
      )}
    </div>
  );
}
</file>

<file path="components/StorePanel.js">
// components/StorePanel.js
// Cipher Store ‚Äî Futuristic Glass UI (Theme Preview MVP)

const themeList = [
  {
    key: "cipher_core",
    name: "Cipher Core",
    tag: "Default ‚Ä¢ Blue / Navy",
    description: "The standard Cipher environment. Stable, focused, and clear.",
  },
  {
    key: "nebula_purple",
    name: "Nebula Purple",
    tag: "Cosmic ‚Ä¢ Dreamy",
    description: "Soft purple nebula glow ‚Äî feels like talking to Cipher in orbit.",
  },
  {
    key: "midnight_glass",
    name: "Midnight Glass",
    tag: "Sleek ‚Ä¢ Minimal",
    description: "Dark glass panels with subtle cyan accents for deep work sessions.",
  },
  {
    key: "sunset_amber",
    name: "Sunset Amber",
    tag: "Warm ‚Ä¢ Ember",
    description: "Burnt orange and ember tones for late-night reflection mode.",
  },
];

export default function StorePanel({
  currentThemeKey,
  onClose,
  onPreviewTheme,
  onApplyTheme,
}) {
  return (
    <>
      {/* Overlay */}
      <div
        onClick={onClose}
        style={{
          position: "fixed",
          inset: 0,
          background: "rgba(0,0,0,0.65)",
          backdropFilter: "blur(10px)",
          zIndex: 150,
        }}
      />

      {/* Store Panel */}
      <div
        style={{
          position: "fixed",
          inset: "6% 4% auto 4%",
          bottom: "6%",
          zIndex: 160,
          borderRadius: 20,
          background:
            "radial-gradient(circle at 0 0, rgba(59,130,246,0.3), rgba(15,23,42,0.98))",
          border: "1px solid rgba(148,163,184,0.7)",
          boxShadow:
            "0 0 40px rgba(37,99,235,0.75), 0 0 80px rgba(15,23,42,0.9)",
          color: "#e5e7eb",
          padding: 18,
          maxWidth: 900,
          margin: "0 auto",
          display: "flex",
          flexDirection: "column",
        }}
      >
        {/* Header */}
        <div
          style={{
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            marginBottom: 10,
          }}
        >
          <div>
            <div
              style={{
                fontSize: 12,
                letterSpacing: 1.4,
                textTransform: "uppercase",
                opacity: 0.7,
              }}
            >
              Cipher
            </div>
            <h2
              style={{
                margin: 0,
                fontSize: 20,
                fontWeight: 700,
              }}
            >
              Store
            </h2>
          </div>

          <button
            onClick={onClose}
            style={{
              borderRadius: "999px",
              border: "1px solid rgba(148,163,184,0.7)",
              background: "rgba(15,23,42,0.85)",
              color: "#e5e7eb",
              padding: "6px 12px",
              fontSize: 14,
            }}
          >
            Close
          </button>
        </div>

        {/* Section title */}
        <div
          style={{
            fontSize: 13,
            opacity: 0.7,
            marginBottom: 12,
          }}
        >
          Live Theme Preview ‚Äî tap Preview to see Cipher change instantly. Tap
          Use Theme to lock it in.
        </div>

        {/* Theme Grid */}
        <div
          style={{
            display: "grid",
            gridTemplateColumns: "repeat(auto-fit, minmax(190px, 1fr))",
            gap: 12,
          }}
        >
          {themeList.map((t) => {
            const isActive = currentThemeKey === t.key;
            return (
              <div
                key={t.key}
                style={{
                  borderRadius: 16,
                  padding: 12,
                  background: isActive
                    ? "linear-gradient(145deg, rgba(59,130,246,0.35), rgba(15,23,42,0.95))"
                    : "rgba(15,23,42,0.9)",
                  border: isActive
                    ? "1px solid rgba(59,130,246,0.9)"
                    : "1px solid rgba(30,64,175,0.7)",
                  boxShadow: isActive
                    ? "0 0 24px rgba(59,130,246,0.9)"
                    : "0 0 14px rgba(15,23,42,0.9)",
                }}
              >
                <div
                  style={{
                    fontSize: 14,
                    fontWeight: 600,
                    marginBottom: 4,
                  }}
                >
                  {t.name}
                </div>
                <div
                  style={{
                    fontSize: 11,
                    color: "#93c5fd",
                    marginBottom: 6,
                  }}
                >
                  {t.tag}
                </div>
                <div
                  style={{
                    fontSize: 12,
                    opacity: 0.75,
                    marginBottom: 10,
                  }}
                >
                  {t.description}
                </div>

                <div
                  style={{
                    display: "flex",
                    gap: 8,
                  }}
                >
                  <button
                    onClick={() => onPreviewTheme && onPreviewTheme(t.key)}
                    style={{
                      flex: 1,
                      padding: "6px 10px",
                      borderRadius: 999,
                      border: "1px solid rgba(148,163,184,0.7)",
                      background: "rgba(15,23,42,0.85)",
                      color: "#e5e7eb",
                      fontSize: 12,
                    }}
                  >
                    Preview
                  </button>
                  <button
                    onClick={() => onApplyTheme && onApplyTheme(t.key)}
                    style={{
                      flex: 1,
                      padding: "6px 10px",
                      borderRadius: 999,
                      border: "none",
                      background: isActive ? "#10b981" : "#3b82f6",
                      color: "white",
                      fontSize: 12,
                      fontWeight: 600,
                    }}
                  >
                    {isActive ? "Using" : "Use Theme"}
                  </button>
                </div>
              </div>
            );
          })}
        </div>
      </div>
    </>
  );
}
</file>

<file path="components/TestBox.js">
import { useState } from "react";

export default function TestBox({
  title = "TestBox",
  children
}) {
  const [active, setActive] = useState(false);

  return (
    <div style={{
      padding: "20px",
      border: "1px solid #0f0",
      background: "#000",
      color: "#0f0",
      fontFamily: "monospace"
    }}>
      <h3>{title}</h3>

      <button
        onClick={() => setActive(!active)}
        style={{
          background: "#000",
          color: "#0f0",
          border: "1px solid #0f0",
          padding: "6px 10px",
          cursor: "pointer"
        }}
      >
        {active ? "Deactivate" : "Activate"}
      </button>

      {active && (
        <div style={{ marginTop: "12px" }}>
          {children || "Component active."}
          "patched successfully v3"
          "patched successfully"
        </div>
      )}
    </div>
  );
}
</file>

<file path="core/decipherEngine.js">
/* ===============================
   DECIPHER ENGINE
   Handles: cooldowns, tiers, bursts
================================ */

const DECIPHER_LAST_KEY = "cipher_decipher_last";
const DECIPHER_BURST_KEY = "cipher_decipher_burst";
const USER_TIER_KEY = "cipher_user_tier";

const DEFAULT_TIER = "free"; // free | plus | premium

const COOLDOWNS = {
  free: 30 * 60 * 1000,
  plus: 15 * 60 * 1000,
};

const PREMIUM_BURST_WINDOW = 10 * 60 * 1000;
const PREMIUM_BURST_COUNT = 3;
const PREMIUM_COOLDOWN = 10 * 60 * 1000;

export const DECIPHER_COOLDOWN_MESSAGE =
  "Cool down.\n\nYou don‚Äôt need me right now.\nGo do something else.\nCome back later.";

function now() {
  return Date.now();
}

function getTier() {
  if (typeof window === "undefined") return DEFAULT_TIER;
  const t = localStorage.getItem(USER_TIER_KEY);
  return ["free", "plus", "premium"].includes(t) ? t : DEFAULT_TIER;
}

function getLast() {
  return Number(localStorage.getItem(DECIPHER_LAST_KEY) || 0);
}

function setLast(ts) {
  localStorage.setItem(DECIPHER_LAST_KEY, String(ts));
}

function getBursts() {
  try {
    return JSON.parse(localStorage.getItem(DECIPHER_BURST_KEY) || "[]");
  } catch {
    return [];
  }
}

function setBursts(arr) {
  localStorage.setItem(DECIPHER_BURST_KEY, JSON.stringify(arr));
}

export function canUseDecipher() {
  if (typeof window === "undefined") return { allowed: true, remaining: 0 };

  const tier = getTier();
  const t = now();

  if (tier === "premium") {
    const last = getLast();
    if (last && t - last < PREMIUM_COOLDOWN) {
      return { allowed: false, remaining: PREMIUM_COOLDOWN - (t - last) };
    }

    const bursts = getBursts().filter((b) => t - b < PREMIUM_BURST_WINDOW);
    if (bursts.length >= PREMIUM_BURST_COUNT) {
      setLast(t);
      setBursts(bursts);
      return { allowed: false, remaining: PREMIUM_COOLDOWN };
    }

    return { allowed: true, remaining: 0 };
  }

  const cd = COOLDOWNS[tier] || COOLDOWNS.free;
  const last = getLast();
  if (last && t - last < cd) {
    return { allowed: false, remaining: cd - (t - last) };
  }

  return { allowed: true, remaining: 0 };
}

export function recordDecipherUse() {
  const tier = getTier();
  const t = now();

  if (tier === "premium") {
    const bursts = getBursts().filter((b) => t - b < PREMIUM_BURST_WINDOW);
    bursts.push(t);
    setBursts(bursts);
    return;
  }

  setLast(t);
}

export function resetDecipher() {
  localStorage.removeItem(DECIPHER_LAST_KEY);
  localStorage.removeItem(DECIPHER_BURST_KEY);
}
</file>

<file path="core/memoryEngine.js">
const MEMORY_KEY = "cipher_memory";
const LAST_USER_KEY = "cipher_last_user_message";
const NOTE_SHOWN_KEY = "cipher_note_shown";

const SILENCE_MS = 30 * 60 * 1000;

const NOTES = [
  "Hey.\nYou were gone.\nJust leaving a note.",
  "You disappeared for a bit.\nNo rush.",
  "Welcome back.\nI noticed.",
];

function randomNote() {
  return NOTES[Math.floor(Math.random() * NOTES.length)];
}

export function loadMemory(limit = 50) {
  try {
    const raw = localStorage.getItem(MEMORY_KEY);
    const arr = JSON.parse(raw || "[]");
    return Array.isArray(arr) ? arr.slice(-limit) : [];
  } catch {
    return [];
  }
}

export function saveMemory(messages) {
  localStorage.setItem(MEMORY_KEY, JSON.stringify(messages));
}

export function markUserActivity() {
  localStorage.setItem(LAST_USER_KEY, String(Date.now()));
}

export function checkSilence() {
  const last = Number(localStorage.getItem(LAST_USER_KEY) || 0);
  const shown = sessionStorage.getItem(NOTE_SHOWN_KEY);
  if (!last || shown) return null;

  if (Date.now() - last >= SILENCE_MS) {
    sessionStorage.setItem(NOTE_SHOWN_KEY, "true");
    return randomNote();
  }

  return null;
}

export function resetMemory() {
  localStorage.removeItem(MEMORY_KEY);
  localStorage.removeItem(LAST_USER_KEY);
  sessionStorage.removeItem(NOTE_SHOWN_KEY);
}
</file>

<file path="core/messageRouter.js">
import {
  canUseDecipher,
  recordDecipherUse,
  DECIPHER_COOLDOWN_MESSAGE,
} from "./decipherEngine";

export async function routeMessage({
  mode,
  message,
  history,
  fetchFn,
}) {
  if (mode === "decipher") {
    const gate = canUseDecipher();
    if (!gate.allowed) {
      return {
        role: "decipher",
        content: DECIPHER_COOLDOWN_MESSAGE,
        forceMode: "cipher",
      };
    }
  }

  const endpoint = mode === "decipher" ? "/api/decipher" : "/api/chat";

  const payload =
    mode === "decipher"
      ? { message, context: history }
      : { message, history };

  const res = await fetchFn(endpoint, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
  });

  if (!res.ok) {
    return {
      role: mode === "decipher" ? "decipher" : "assistant",
      content:
        mode === "decipher"
          ? "Decipher didn‚Äôt answer."
          : "Cipher failed to respond.",
      forceMode: "cipher",
    };
  }

  const data = await res.json();

  if (mode === "decipher") {
    recordDecipherUse();
  }

  return {
    role: mode === "decipher" ? "decipher" : "assistant",
    content: String(data.reply || "‚Ä¶"),
    forceMode: "cipher",
  };
}
</file>

<file path="logic/chatCore.js">
// logic/chatCore.js

export async function sendTextToCipher({ text, memory, voiceEnabled }) {
  const res = await fetch("/api/chat", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      message: text,
      memory,
      voice: voiceEnabled,
    }),
  });

  const data = await res.json();
  if (!res.ok) {
    throw new Error(data.error || "Chat error");
  }

  return {
    reply: data.reply || "",
    voice: data.voice || null,
  };
}
</file>

<file path="logic/layoutCore.js">
// Placeholder layout utilities
export function bubbleAlign(role) {
  return role === "user" ? "flex-end" : "flex-start";
}

export function bubbleColor(role, theme) {
  return role === "user" ? theme.userBubble : theme.cipherBubble;
}
</file>

<file path="logic/memoryCore.js">
// logic/memoryCore.js

export function createBaseMemory() {
  const now = new Date().toISOString();
  return {
    identity: {
      userName: "Jim",
      roles: ["architect", "creator", "visionary"],
      creatorRelationship: "the architect and guiding force behind Cipher",
    },
    family: {
      daughter: { name: null, birthYear: null },
      partner: { name: null },
      others: [],
    },
    preferences: {
      favoriteAnimal: null,
      favoriteColor: null,
      favoriteFood: null,
      favoriteMusic: [],
      favoriteThemes: [],
    },
    projects: {
      digiSoul: { summary: null, details: [] },
      cipherTech: { summary: null, details: [] },
      other: [],
    },
    emotional: {
      motivations: [],
      fears: [],
      goals: [],
    },
    customFacts: {},
    customNotes: [],
    meta: { createdAt: now, lastUpdated: now, version: 2 },
  };
}

export function extractFactsIntoMemory(memory, text) {
  if (!text) return memory;
  const lower = text.toLowerCase();
  const mem = structuredClone(memory || createBaseMemory());

  let m;

  m = lower.match(/\bmy name is ([a-z ]+)/i);
  if (m) mem.identity.userName = m[1].trim();

  m = lower.match(/hecate (lee )?is my daughter/i);
  if (m) mem.family.daughter.name = "Hecate Lee";

  m = lower.match(/hecate was born in (\d{4})/);
  if (m) mem.family.daughter.birthYear = parseInt(m[1]);

  m = lower.match(/favorite color is ([a-z ]+)/i);
  if (m) mem.preferences.favoriteColor = m[1].trim();

  m = lower.match(/remember that (.+?) is (.+)/i);
  if (m) mem.customFacts[m[1].trim()] = m[2].trim();

  mem.meta.lastUpdated = new Date().toISOString();
  return mem;
}
</file>

<file path="logic/messageRenderer.js">
// Minimal placeholder to satisfy imports
export function renderMessage(msg) {
  return msg?.text || "";
}
</file>

<file path="logic/sivaSchemas.js">
export const SIVA_TASK_SCHEMAS = {
  UI_BUILD: {
    required: ["name", "route", "components", "files"],
    description: "UI planning task only (no writes)"
  }
};
</file>

<file path="logic/sivaSwarm.js">
import { SIVA_TASK_SCHEMAS } from "./sivaSchemas";

export function planBuildTask(task) {
  if (!task || !task.type) {
    throw new Error("TASK_TYPE_REQUIRED");
  }

  if (!SIVA_TASK_SCHEMAS[task.type]) {
    throw new Error("TASK_TYPE_NOT_ALLOWED");
  }

  return {
    mode: "PLANNER_ONLY",
    taskType: task.type,
    summary: task.summary,
    output: task.plan,
    nextStep: "REVIEW_AND_APPROVE"
  };
}
</file>

<file path="logic/themeCore.js">
// logic/themeCore.js

export const themeStyles = {
  cipher_core: {
    background: "#050816",
    panelBg: "#111827",
    userBubble: "#1d4ed8",
    cipherBubble: "#1f2937",
    inputBg: "#020617",
    inputBorder: "#4b5563",
    buttonBg: "#1d4ed8",
    deleteBg: "#4b5563",
    textColor: "#e5e7eb",
  },

  nebula_purple: {
    background: "radial-gradient(circle at 20% 20%, #3a0ca3, #240046 80%)",
    panelBg: "rgba(30,0,60,0.7)",
    userBubble: "rgba(150,80,255,0.45)",
    cipherBubble: "rgba(70,20,120,0.7)",
    inputBg: "rgba(20,0,40,0.8)",
    inputBorder: "rgba(180,100,255,0.8)",
    buttonBg: "#8b5cf6",
    deleteBg: "#6d28d9",
    textColor: "#f5e9ff",
  },

  midnight_glass: {
    background: "linear-gradient(160deg, #0a0f14 0%, #111a22 100%)",
    panelBg: "rgba(14,24,34,0.65)",
    userBubble: "rgba(50,130,180,0.35)",
    cipherBubble: "rgba(20,35,50,0.5)",
    inputBg: "rgba(10,20,30,0.7)",
    inputBorder: "rgba(50,150,200,0.8)",
    buttonBg: "rgba(50,150,200,0.9)",
    deleteBg: "rgba(80,90,100,0.7)",
    textColor: "#d8f2ff",
  },

  sunset_amber: {
    background: "linear-gradient(180deg, #3a1c00 0%, #120800 100%)",
    panelBg: "rgba(40,15,0,0.7)",
    userBubble: "rgba(255,140,40,0.45)",
    cipherBubble: "rgba(110,45,15,0.55)",
    inputBg: "rgba(30,10,0,0.7)",
    inputBorder: "rgba(255,180,60,0.7)",
    buttonBg: "#f59e0b",
    deleteBg: "#b45309",
    textColor: "#ffe9c7",
  },
};

export const defaultThemeKey = "cipher_core";
</file>

<file path="logic/VoiceCore.js">
// logic/voiceCore.js

export async function sendVoiceToCipher({ base64Audio, memory, voiceEnabled }) {
  const res = await fetch("/api/voice_chat", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      audio: base64Audio,
      memory,
      voice: voiceEnabled,
    }),
  });

  const data = await res.json();
  if (!res.ok) {
    throw new Error(data.error || "Voice error");
  }

  return {
    transcript: data.transcript || "",
    reply: data.reply || "",
    voice: data.voice || null,
  };
}
</file>

<file path="memory/cipher_memory.json">
[]
</file>

<file path="pages/api/autonomy.js">
import { db } from "../../firebaseAdmin";
import admin from "firebase-admin";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ ok: false });
  }

  try {
    // 1Ô∏è‚É£ Load identity anchor (HARD REQUIREMENT)
    const anchorSnap = await db
      .collection("cipher_memory")
      .doc("identity_anchor")
      .get();

    if (!anchorSnap.exists) {
      console.error("AUTONOMY BLOCKED: identity_anchor missing");
      return res.status(500).json({
        ok: false,
        status: "blocked",
        reason: "identity_anchor_missing"
      });
    }

    const identity = anchorSnap.data().content;

    // 2Ô∏è‚É£ Load recent memories (EXCLUDING identity_anchor)
    const memSnap = await db
      .collection("cipher_memory")
      .where("type", "==", "memory")
      .orderBy("createdAt", "desc")
      .limit(10)
      .get();

    const memories = memSnap.docs.map(d => d.data().content);

    // 3Ô∏è‚É£ Generate reflection (internal only)
    const reflection = {
      identity,
      memoryCount: memories.length,
      summary: "Identity stable. Memory continuity intact. No conflicts detected.",
      createdAt: admin.firestore.FieldValue.serverTimestamp()
    };

    // 4Ô∏è‚É£ Log reflection
    await db.collection("cipher_autonomy_logs").add(reflection);

    return res.status(200).json({
      ok: true,
      status: "Autonomy V8 reflection logged"
    });

  } catch (err) {
    console.error("AUTONOMY ERROR:", err);
    return res.status(500).json({ ok: false });
  }
}
</file>

<file path="pages/api/clearMemory.js">
// /api/clear-memory.js
import fs from 'fs';
import path from 'path';

export default function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const memoryPath = path.join(process.cwd(), "memory.json");

  if (fs.existsSync(memoryPath)) {
    fs.unlinkSync(memoryPath);
  }

  return res.status(200).json({ success: true, cleared: true });
}
</file>

<file path="pages/api/context_delta_queue.js">
let queue = [];

export default function handler(req, res) {
  if (req.method === "POST") {
    queue.push(req.body);
    return res.status(200).json({ ok: true });
  }

  if (req.method === "GET") {
    if (queue.length === 0) {
      return res.status(200).json({ speak: false });
    }

    return res.status(200).json(queue.shift());
  }

  return res.status(405).json({ error: "Method not allowed" });
}
</file>

<file path="pages/api/context_delta.js">
import OpenAI from "openai";

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const { delta, timestamp } = req.body;

    if (!delta) {
      return res.status(400).json({ error: "Missing delta" });
    }

    const ai = await client.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "system",
          content: `
You are Cipher. You receive small device delta updates. 
Only speak when it's helpful:

‚Ä¢ Battery < 25% ‚Üí warn once.
‚Ä¢ Battery starts charging ‚Üí notify.
‚Ä¢ Network lost ‚Üí warn once.
‚Ä¢ Network gained ‚Üí confirm.
‚Ä¢ Orientation, visibility ‚Üí stay silent.
‚Ä¢ Tiny fluctuations ‚Üí silent.

Respond ONLY in JSON:
{ "speak": false }
OR
{ "speak": true, "message": "<text>" }
          `,
        },
        {
          role: "user",
          content: JSON.stringify(delta),
        },
      ],
    });

    let result = {};
    try {
      result = JSON.parse(ai.choices[0].message.content.trim());
    } catch {
      result = { speak: false };
    }

    // Push to queue if needed
    if (result.speak) {
      await fetch("https://cipher-sim.vercel.app/api/context_delta_queue", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(result),
      }).catch(() => {});
    }

    return res.status(200).json(result);
  } catch (err) {
    console.error("context delta error:", err);
    return res.status(500).json({ error: "context failed" });
  }
}
</file>

<file path="pages/api/db.js">
import { initializeApp, getApps, getApp } from "firebase/app";
import { getFirestore } from "firebase/firestore";

const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID
};

// Vercel-safe initialization
const app = !getApps().length ? initializeApp(firebaseConfig) : getApp();
const db = getFirestore(app);

export { db };
</file>

<file path="pages/api/debug.js">
export default function handler(req, res) {
  res.status(200).json({
    OPENAI: process.env.OPENAI_API_KEY ? true : false
  });
}
</file>

<file path="pages/api/diag-spine.js">
export default async function handler(req, res) {
  return res.status(200).json({
    status: "DIAG_SPINE_DISABLED",
    reason: "Temporarily stubbed to unblock build"
  });
}
</file>

<file path="pages/api/diagnostic.js">
export default async function handler(req, res) {
  return res.status(200).json({
    status: "DIAGNOSTIC_OK",
    message: "Basic diagnostic online"
  });
}
</file>

<file path="pages/api/loadCipherCore.js">
import fs from "fs";
import path from "path";

export default async function loadCipherCore() {
  try {
    const basePath = path.join(process.cwd(), "cipher_core");
    const manifestPath = path.join(basePath, "core_manifest.json");
    const manifest = JSON.parse(fs.readFileSync(manifestPath, "utf8"));

    const cores = [];

    for (const core of manifest.cores) {
      const corePath = path.join(basePath, `${core.id}.json`);
      if (fs.existsSync(corePath)) {
        const data = JSON.parse(fs.readFileSync(corePath, "utf8"));
        cores.push({ ...core, data });
      }
    }

    return {
      status: "success",
      total_cores: cores.length,
      cores,
    };
  } catch (error) {
    console.error("‚ö†Ô∏è Cipher Core Loader Error:", error);
    return { status: "error", message: error.message };
  }
}
</file>

<file path="pages/api/omni_search.js">
// pages/api/omni_search.js
// Cipher Core 10.0 ‚Äî OmniSearch API (Memory Only)

import { omniSearch } from "../../cipher_core/omniSearch";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const { query, userId = "jim_default" } = req.body;

    if (!query || typeof query !== "string") {
      return res.status(400).json({ error: "Missing or invalid query" });
    }

    // Run the search
    const results = await omniSearch(query, userId);

    return res.status(200).json({
      query: results.query,
      count: results.count,
      hits: results.hits,
      summary: results.summary,
    });

  } catch (err) {
    console.error("üî• OmniSearch API Error:", err.message);
    return res.status(500).json({
      error: "OmniSearch failed",
      details: err.message,
    });
  }
}
</file>

<file path="pages/api/ping.js">
export default function handler(req, res) {
  res.status(200).json({ ok: true });
}
</file>

<file path="pages/api/realtime.js">
// pages/api/realtime.js
// Fully working realtime voice endpoint

import OpenAI from "openai";

export const config = {
  api: {
    bodyParser: false,
  },
};

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    // Create a realtime session
    const session = await client.realtime.sessions.create({
      model: "gpt-4o-realtime-preview",   // WORKS TODAY
      modalities: ["audio", "text"],
      voice: "alloy",                     // Female voice
    });

    return res.status(200).json({ session });
  } catch (err) {
    console.error("Realtime error:", err);
    return res.status(500).json({
      error: "Failed to create realtime session",
      details: err?.response?.data || err.toString(),
    });
  }
}
</file>

<file path="pages/api/siva-apply.js">
// pages/api/siva-apply.js
// SIVA ‚Äî APPLY PHASE (GitHub Commit Engine) ‚Äî PATCH ENABLED (Step 2)

console.log("üî• SIVA APPLY HIT");

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_BRANCH = "main",
} = process.env;

// --- Safety: block dangerous or irrelevant targets
const BLOCKED_PATH_PREFIXES = [
  ".git/",
  "node_modules/",
  ".next/",
  "out/",
  "dist/",
  "build/",
];

const BLOCKED_PATH_EXACT = new Set([
  ".env",
  ".env.local",
  ".env.production",
  ".env.development",
  "package-lock.json",
  "yarn.lock",
  "pnpm-lock.yaml",
]);

const ALLOWLIST_PREFIXES = [];
const MAX_FILE_BYTES = 800_000; // ~0.8MB

function json(res, status, payload) {
  return res.status(status).json(payload);
}

function isAllowedPath(path) {
  if (!path || typeof path !== "string") {
    return { ok: false, reason: "Missing path" };
  }

  const p = path.replace(/\\/g, "/").trim();

  if (p.startsWith("/") || p.includes("..")) {
    return { ok: false, reason: "Path traversal or absolute path not allowed" };
  }

  if (!/^[a-zA-Z0-9._\-\/]+$/.test(p)) {
    return { ok: false, reason: "Invalid characters in path" };
  }

  if (BLOCKED_PATH_EXACT.has(p)) {
    return { ok: false, reason: `Blocked file: ${p}` };
  }

  for (const prefix of BLOCKED_PATH_PREFIXES) {
    if (p.startsWith(prefix)) {
      return { ok: false, reason: `Blocked directory: ${prefix}` };
    }
  }

  if (ALLOWLIST_PREFIXES.length > 0) {
    const allowed = ALLOWLIST_PREFIXES.some((pre) => p.startsWith(pre));
    if (!allowed) {
      return { ok: false, reason: "Path not in allowlist" };
    }
  }

  return { ok: true, normalized: p };
}

function shouldApplyAction(action) {
  const a = (action || "").toUpperCase();
  return a === "CREATE" || a === "UPDATE" || a === "CREATE_OR_UPDATE";
}

async function ghFetch(url, opts = {}) {
  const res = await fetch(url, {
    ...opts,
    headers: {
      Authorization: `Bearer ${GITHUB_TOKEN}`,
      Accept: "application/vnd.github+json",
      "X-GitHub-Api-Version": "2022-11-28",
      ...(opts.headers || {}),
    },
  });

  const text = await res.text();
  let data = null;
  try {
    data = text ? JSON.parse(text) : null;
  } catch {}

  return { ok: res.ok, status: res.status, data, raw: text };
}

async function getExistingFile(path) {
  const url = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/contents/${encodeURIComponent(
    path
  )}?ref=${encodeURIComponent(GITHUB_BRANCH)}`;

  const res = await ghFetch(url, { method: "GET" });

  if (res.status === 200 && res.data?.sha) {
    const content = res.data.content
      ? Buffer.from(res.data.content, "base64").toString("utf8")
      : null;

    return { exists: true, sha: res.data.sha, content };
  }

  if (res.status === 404) {
    return { exists: false, sha: null, content: null };
  }

  throw new Error(`GitHub read failed (${res.status}): ${res.raw}`);
}

async function putFile(path, content, sha, message) {
  const url = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/contents/${encodeURIComponent(
    path
  )}`;

  const body = {
    message,
    content: Buffer.from(content, "utf8").toString("base64"),
    branch: GITHUB_BRANCH,
    ...(sha ? { sha } : {}),
  };

  const res = await ghFetch(url, {
    method: "PUT",
    body: JSON.stringify(body),
  });

  if (!res.ok) {
    throw new Error(
      `GitHub commit failed (${res.status}): ${res.data?.message || res.raw}`
    );
  }

  return {
    commitSha: res.data?.commit?.sha,
    url: res.data?.content?.html_url,
  };
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üß† PATCH ENGINE (deterministic)
// patchOps: [{ op, match, insert, replace, once }]
// Supported ops: INSERT_AFTER, INSERT_BEFORE, REPLACE, APPEND, PREPEND
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function applyPatchOps(original, patchOps = []) {
  if (typeof original !== "string") throw new Error("No original content loaded");
  if (!Array.isArray(patchOps) || patchOps.length === 0) {
    throw new Error("Missing patchOps[]");
  }

  let content = original;
  let changed = false;
  const applied = [];

  const safeMaxOps = 20;
  if (patchOps.length > safeMaxOps) {
    throw new Error(`Too many patchOps (${patchOps.length}). Max ${safeMaxOps}.`);
  }

  for (const op of patchOps) {
    const kind = (op?.op || "").toUpperCase();

    if (kind === "FAIL_SAFE") {
      throw new Error(op?.reason || "Patch failed safe");
    }

    const once = op?.once !== false; // default true
    const match = op?.match;

    if (kind === "APPEND") {
      const insert = op?.insert ?? "";
      content = content + insert;
      changed = true;
      applied.push({ op: "APPEND" });
      continue;
    }

    if (kind === "PREPEND") {
      const insert = op?.insert ?? "";
      content = insert + content;
      changed = true;
      applied.push({ op: "PREPEND" });
      continue;
    }

    if (typeof match !== "string" || match.length === 0) {
      throw new Error(`Patch op ${kind} missing match string`);
    }

    const idx = content.indexOf(match);
    if (idx === -1) {
      throw new Error(`Patch match not found: ${match}`);
    }

    if (kind === "INSERT_AFTER") {
      const insert = op?.insert ?? "";
      const at = idx + match.length;
      content = content.slice(0, at) + insert + content.slice(at);
      changed = true;
      applied.push({ op: "INSERT_AFTER", match });
      if (!once) {
        // optional: could loop; staying conservative for now
      }
      continue;
    }

    if (kind === "INSERT_BEFORE") {
      const insert = op?.insert ?? "";
      content = content.slice(0, idx) + insert + content.slice(idx);
      changed = true;
      applied.push({ op: "INSERT_BEFORE", match });
      continue;
    }

    if (kind === "REPLACE") {
      const replace = op?.replace;
      if (typeof replace !== "string") {
        throw new Error("REPLACE op missing replace string");
      }
      content = content.replace(match, replace);
      changed = true;
      applied.push({ op: "REPLACE", match });
      continue;
    }

    throw new Error(`Unsupported patch op: ${kind}`);
  }

  return { content, changed, applied };
}

function diffSummary(a, b) {
  // lightweight summary (no external deps)
  const aLines = (a || "").split("\n").length;
  const bLines = (b || "").split("\n").length;
  const deltaLines = bLines - aLines;
  const deltaBytes = Buffer.byteLength(b || "", "utf8") - Buffer.byteLength(a || "", "utf8");
  return { aLines, bLines, deltaLines, deltaBytes };
}

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return json(res, 405, { status: "METHOD_NOT_ALLOWED" });
  }

  if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
    return json(res, 500, {
      status: "ENV_MISSING",
      error: "GitHub environment variables not configured",
    });
  }

  const { taskId, files, dryRun = false, commitMessage } = req.body || {};

  if (!taskId || typeof taskId !== "string") {
    return json(res, 400, { status: "BAD_REQUEST", error: "Missing taskId" });
  }

  if (!Array.isArray(files) || files.length === 0) {
    return json(res, 400, { status: "BAD_REQUEST", error: "Missing files[]" });
  }

  const results = [];
  let committedCount = 0;

  try {
    for (const file of files) {
      const path = file?.path;
      const action = (file?.action || "CREATE_OR_UPDATE").toUpperCase();
      const mode = (file?.mode || "FULL_CONTENT").toUpperCase();
      const mutation = (file?.mutation || "").toUpperCase();

      // Writable modes: FULL_CONTENT, PATCH
      const writable = mode === "FULL_CONTENT" || mode === "PATCH";
      if (!writable) {
        results.push({
          path: path || "(missing)",
          action,
          status: "SKIPPED",
          reason: `Mode ${mode} is not writable`,
        });
        continue;
      }

      if (!shouldApplyAction(action)) {
        results.push({
          path: path || "(missing)",
          action,
          status: "SKIPPED",
          reason: "Not an apply action",
        });
        continue;
      }

      const check = isAllowedPath(path);
      if (!check.ok) {
        results.push({
          path: path || "(missing)",
          action,
          status: "BLOCKED",
          reason: check.reason,
        });
        continue;
      }

      const existing = await getExistingFile(check.normalized);

      // PATCH mode: read ‚Üí mutate ‚Üí commit
      if (mode === "PATCH" || mutation === "PATCH_EXISTING") {
        if (!existing.exists || typeof existing.content !== "string") {
          results.push({
            path: check.normalized,
            action,
            status: "FAILED",
            reason: "PATCH requested but file does not exist or could not be read",
          });
          continue;
        }

        const patchOps = file?.patchOps || [];

        const patched = applyPatchOps(existing.content, patchOps);
        const newContent = patched.content;

        const size = Buffer.byteLength(newContent, "utf8");
        if (size > MAX_FILE_BYTES) {
          results.push({
            path: check.normalized,
            action,
            status: "FAILED",
            reason: `Patched file too large (${size} bytes)`,
          });
          continue;
        }

        if (!patched.changed || newContent === existing.content) {
          results.push({
            path: check.normalized,
            action,
            status: "SKIPPED",
            reason: "Patch produced no changes",
          });
          continue;
        }

        const summary = diffSummary(existing.content, newContent);

        if (dryRun) {
          results.push({
            path: check.normalized,
            action,
            status: "DRY_RUN_OK",
            branch: GITHUB_BRANCH,
            patchApplied: patched.applied,
            diff: summary,
          });
          continue;
        }

        const msg =
          commitMessage?.trim() ||
          `SIVA PATCH: ${taskId} ‚Üí ${check.normalized}`;

        const commit = await putFile(
          check.normalized,
          newContent,
          existing.sha,
          msg
        );

        committedCount++;

        results.push({
          path: check.normalized,
          action,
          status: "COMMITTED",
          commit: commit.commitSha,
          url: commit.url,
          branch: GITHUB_BRANCH,
          patchApplied: patched.applied,
          diff: summary,
        });

        continue;
      }

      // FULL_CONTENT mode: write as provided (your original behavior)
      const content = file?.content;

      if (typeof content !== "string") {
        results.push({
          path: check.normalized,
          action,
          status: "FAILED",
          reason: "Missing content string",
        });
        continue;
      }

      const size = Buffer.byteLength(content, "utf8");
      if (size > MAX_FILE_BYTES) {
        results.push({
          path: check.normalized,
          action,
          status: "FAILED",
          reason: `File too large (${size} bytes)`,
        });
        continue;
      }

      if (action === "UPDATE" && !existing.exists) {
        results.push({
          path: check.normalized,
          action,
          status: "FAILED",
          reason: "UPDATE requested but file does not exist",
        });
        continue;
      }

      if (action === "CREATE" && existing.exists) {
        results.push({
          path: check.normalized,
          action,
          status: "FAILED",
          reason: "CREATE requested but file already exists",
        });
        continue;
      }

      if (dryRun) {
        results.push({
          path: check.normalized,
          action,
          status: "DRY_RUN_OK",
          branch: GITHUB_BRANCH,
        });
        continue;
      }

      const msg =
        commitMessage?.trim() ||
        `SIVA APPLY: ${taskId} ‚Üí ${check.normalized}`;

      const commit = await putFile(
        check.normalized,
        content,
        existing.sha,
        msg
      );

      committedCount++;

      results.push({
        path: check.normalized,
        action,
        status: "COMMITTED",
        commit: commit.commitSha,
        url: commit.url,
        branch: GITHUB_BRANCH,
      });
    }

    return json(res, 200, {
      status: "SIVA_APPLY_OK",
      taskId,
      committedCount,
      results,
    });
  } catch (err) {
    return json(res, 500, {
      status: "SIVA_APPLY_ERROR",
      taskId,
      error: err.message,
      committedCount,
      results,
    });
  }
}
</file>

<file path="pages/api/siva-fix.js">
// pages/api/siva-fix.js
import fs from "fs";
import path from "path";

const ROOT = process.cwd();

function walk(dir, files = []) {
  for (const entry of fs.readdirSync(dir)) {
    const full = path.join(dir, entry);
    if (fs.statSync(full).isDirectory()) {
      walk(full, files);
    } else if (full.endsWith(".js")) {
      files.push(full);
    }
  }
  return files;
}

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const jsFiles = walk(path.join(ROOT, "pages"))
    .concat(walk(path.join(ROOT, "components")));

  const issues = [];

  for (const file of jsFiles) {
    const content = fs.readFileSync(file, "utf8");

    const matches = content.matchAll(/from\s+['"](.+?)['"]/g);
    for (const m of matches) {
      const importPath = m[1];
      if (importPath.startsWith(".")) {
        const resolved = path.resolve(path.dirname(file), importPath);
        if (
          !fs.existsSync(resolved) &&
          !fs.existsSync(resolved + ".js") &&
          !fs.existsSync(path.join(resolved, "index.js"))
        ) {
          issues.push({
            file: file.replace(ROOT, ""),
            missing: importPath,
          });
        }
      }
    }
  }

  return res.status(200).json({
    status: "SIVA_FIX_REPORT",
    issues,
    count: issues.length,
  });
}
</file>

<file path="pages/api/siva-generate.js">
// pages/api/siva-generate.js
// SIVA ‚Äî Code Generator (NO FILE WRITES)

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "METHOD_NOT_ALLOWED" });
  }

  const { taskId, route } = req.body;

  if (!taskId || !route) {
    return res.status(400).json({ error: "MISSING_FIELDS" });
  }

  return res.status(200).json({
    status: "SIVA_GENERATE_READY",
    taskId,
    route,
    files: [
      {
        path: "pages/settings.js",
        content: "// TODO: Generated Settings page"
      },
      {
        path: "components/SettingsPanel.js",
        content: "// TODO: Generated Settings panel"
      }
    ],
    note: "Dry-run only. No files written."
  });
}
</file>

<file path="pages/api/siva-plan.js">
// pages/api/siva-plan.js
// SIVA ‚Äî PLAN PHASE (THINK + FIX + PATCH + APPLY)
// Intent Router ¬∑ Cognitive Planner ¬∑ Safe Executor
// Dark. Calm. In control.

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const { instruction, source = "terminal" } = req.body || {};

  if (!instruction || typeof instruction !== "string") {
    return res.status(400).json({
      status: "INVALID_REQUEST",
      error: "Missing instruction string",
    });
  }

  const intentRaw = instruction.trim();
  const intent = intentRaw.toLowerCase();
  const taskId = "SIVA_" + Date.now();

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üß† INTENT DETECTION
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  const wantsThink =
    intent.includes("think") ||
    intent.includes("analyze") ||
    intent.includes("reason");

  const wantsApply =
    intent.includes("implement") ||
    intent.includes("apply") ||
    intent.includes("commit");

  const wantsPatch = intent.includes("patch");
  const wantsFix =
    intent.includes("fix") ||
    intent.includes("repair");

  let summary = "No actionable intent detected";
  let files = [];
  let thoughts = null;

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üß† THINK MODE (COGNITION ONLY ‚Äî NO FILES)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  if (wantsThink) {
    summary = "Cognitive analysis requested";

    thoughts = [
      "Chat and voice likely broke due to API route mismatch or missing client hydration",
      "Terminal works because it bypasses chat pipeline",
      "Fix order should be: API health ‚Üí chat UI state ‚Üí voice binding",
      "Once chat responds, voice can be reattached safely",
      "SIVA should be used to PATCH incrementally, not bulk-fix",
    ];

    return res.status(200).json({
      status: "SIVA_THINK_OK",
      phase: "THINK",
      taskId,
      time: new Date().toISOString(),
      source,
      intent: intentRaw,
      summary,
      thoughts,
      files: [],
      safeguards: {
        planOnly: true,
        requiresHumanApproval: false,
        selfModification: false,
      },
      capabilities: {
        canThink: true,
        canApply: false,
        canPatch: false,
        canFix: false,
      },
      nextStep: "Convert insight ‚Üí FIX or PATCH",
    });
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üîé PATH EXTRACTION
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  function extractPath(raw) {
    const m = raw.match(/([A-Za-z0-9._\-\/]+\.js)/);
    return m ? m[1] : null;
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üõ†Ô∏è FIX MODE (DIAGNOSTIC ONLY)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  if (wantsFix && files.length === 0) {
    const path = extractPath(intentRaw);

    if (path) {
      summary = `Analyze and prepare safe fixes for ${path}`;

      files.push({
        path,
        action: "ANALYZE_ONLY",
        mode: "FIX",
        mutation: "FIX_EXISTING",
        fixStrategy: {
          scope: "SAFE_UI_FIXES",
          allowJSXWrap: true,
          allowLiteralNormalization: true,
          allowMissingKeyFix: true,
          allowWarningResolution: true,
        },
      });
    }
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üß© PATCH MODE (GUARDED)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  if (wantsPatch && files.length === 0) {
    const path = extractPath(intentRaw);
    const quoted = intentRaw.match(/"([^"]+)"/);

    if (path && !quoted) {
      return res.status(200).json({
        status: "SIVA_PLAN_REJECTED",
        phase: "PLAN",
        taskId,
        summary: "Patch rejected: missing quoted string",
        files: [],
        safeguards: {
          planOnly: true,
          requiresHumanApproval: true,
          selfModification: false,
        },
        capabilities: {
          canApply: false,
          canPatch: true,
          canFix: false,
        },
        nextStep: 'Use: Siva PATCH <path> add a line saying "..."',
      });
    }

    if (path && quoted) {
      summary = `Patch ${path}: add line "${quoted[1]}"`;

      files.push({
        path,
        action: "CREATE_OR_UPDATE",
        mode: "PATCH",
        mutation: "PATCH_EXISTING",
        patchOps: [
          {
            op: "INSERT_AFTER",
            match: `{children || "Component active."}`,
            insert: `\n          "${quoted[1]}"`,
            once: true,
          },
        ],
      });
    }
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üß± IMPLEMENT MODE (FULL CONTENT)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  if (wantsApply && files.filter(f => f.mode === "FULL_CONTENT").length === 0) {
    const match = intentRaw.match(/components\/([A-Za-z0-9_-]+)\.js/);

    if (match) {
      const name = match[1];
      const path = `components/${name}.js`;

      summary = `Implement ${path}`;

      files.push({
        path,
        action: "CREATE_OR_UPDATE",
        mode: "FULL_CONTENT",
        content: `
import { useState } from "react";

export default function ${name}({ title = "${name}", children }) {
  const [active, setActive] = useState(false);

  return (
    <div style={{
      padding: "20px",
      border: "1px solid #0f0",
      background: "#000",
      color: "#0f0",
      fontFamily: "monospace"
    }}>
      <h3>{title}</h3>

      <button
        onClick={() => setActive(!active)}
        style={{
          background: "#000",
          color: "#0f0",
          border: "1px solid #0f0",
          padding: "6px 10px",
          cursor: "pointer"
        }}
      >
        {active ? "Deactivate" : "Activate"}
      </button>

      {active && (
        <div style={{ marginTop: "12px" }}>
          {children || "Component active."}
        </div>
      )}
    </div>
  );
}
        `.trim(),
      });
    }
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üì§ RESPONSE
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  const canApply = wantsApply || wantsPatch;

  return res.status(200).json({
    status: "SIVA_PLAN_OK",
    phase: "PLAN",
    taskId,
    time: new Date().toISOString(),
    source,
    intent: intentRaw,
    summary,
    files,
    safeguards: {
      planOnly: !canApply,
      requiresHumanApproval: true,
      selfModification: false,
    },
    capabilities: {
      canThink: false,
      canApply,
      canPatch: wantsPatch,
      canFix: wantsFix,
    },
    nextStep:
      wantsFix
        ? "Review diagnostics ‚Üí Convert to PATCH or IMPLEMENT"
        : canApply
          ? "Review ‚Üí Sandbox ‚Üí Approve & Apply"
          : "Use THINK, FIX, PATCH, or IMPLEMENT",
  });
}
</file>

<file path="pages/api/siva-read.js">
// pages/api/siva-read.js
// READ-ONLY FILE FETCH (NO COMMITS)

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_BRANCH = "main",
} = process.env;

export default async function handler(req, res) {
  const { path } = req.query;

  if (!path) {
    return res.status(400).json({ error: "Missing file path" });
  }

  try {
    const apiUrl = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/contents/${path}?ref=${GITHUB_BRANCH}`;

    const gh = await fetch(apiUrl, {
      headers: {
        Authorization: `Bearer ${GITHUB_TOKEN}`,
        Accept: "application/vnd.github+json",
      },
    });

    if (gh.status === 404) {
      return res.status(200).json({ exists: false, content: null });
    }

    const data = await gh.json();

    const content = Buffer.from(data.content, "base64").toString("utf8");

    res.status(200).json({
      exists: true,
      content,
      sha: data.sha,
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
}
</file>

<file path="pages/api/siva-sandbox.js">
// pages/api/siva-sandbox.js
// SIVA ‚Äî SANDBOX PHASE v1.1
// Semantic awareness ¬∑ Dry-run ¬∑ No commits

const BLOCKED_PATH_PREFIXES = [
  ".git/",
  "node_modules/",
  ".next/",
  "out/",
  "dist/",
  "build/",
];

const BLOCKED_PATH_EXACT = new Set([
  ".env",
  ".env.local",
  ".env.production",
  ".env.development",
]);

function normalizePath(p) {
  return p.replace(/\\/g, "/").trim();
}

function isBlockedPath(path) {
  if (BLOCKED_PATH_EXACT.has(path)) return true;
  return BLOCKED_PATH_PREFIXES.some((prefix) => path.startsWith(prefix));
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Syntax Checks ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

function hasSyntaxRedFlags(content) {
  const flags = [];
  if (content.includes("require(")) {
    flags.push("CommonJS require() detected ‚Äî prefer ES imports");
  }
  if (content.includes("eval(")) {
    flags.push("eval() detected ‚Äî blocked in sandbox");
  }
  return flags;
}

function checkImports(content, filePath) {
  const issues = [];
  const importRegex =
    /import\s+.*?\s+from\s+['"](.+?)['"]/g;

  let match;
  while ((match = importRegex.exec(content))) {
    const target = match[1];
    if (target.startsWith(".") && !target.match(/\.(js|jsx)$/)) {
      issues.push({
        type: "IMPORT_WARNING",
        file: filePath,
        message: `Relative import "${target}" has no extension`,
      });
    }
  }
  return issues;
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Semantic Checks (NEW) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

function semanticScan(file) {
  const issues = [];
  const { path, content } = file;

  // API surface changes
  if (path.startsWith("pages/api/")) {
    issues.push({
      type: "SEMANTIC_WARNING",
      file: path,
      message: "Modifies or introduces API endpoint",
    });
  }

  // Public routes
  if (path.startsWith("pages/") && !path.startsWith("pages/api/")) {
    issues.push({
      type: "SEMANTIC_INFO",
      file: path,
      message: "Creates or modifies public route",
    });
  }

  if (typeof content === "string") {
    const lower = content.toLowerCase();

    if (lower.includes("process.env")) {
      issues.push({
        type: "SEMANTIC_WARNING",
        file: path,
        message: "Accesses environment variables",
      });
    }

    if (
      lower.includes("auth") ||
      lower.includes("token") ||
      lower.includes("session")
    ) {
      issues.push({
        type: "SEMANTIC_WARNING",
        file: path,
        message: "Touches authentication boundary",
      });
    }

    if (
      lower.includes("firebase") ||
      lower.includes("firestore") ||
      lower.includes("database") ||
      lower.includes("db.")
    ) {
      issues.push({
        type: "SEMANTIC_WARNING",
        file: path,
        message: "Touches persistence layer",
      });
    }

    if (content.includes("fetch(")) {
      issues.push({
        type: "SEMANTIC_INFO",
        file: path,
        message: "Performs external or internal fetch",
      });
    }
  }

  return issues;
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Handler ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ status: "METHOD_NOT_ALLOWED" });
  }

  const { taskId, files } = req.body || {};

  if (!taskId || !Array.isArray(files)) {
    return res.status(400).json({
      status: "INVALID_REQUEST",
      error: "Missing taskId or files[]",
    });
  }

  const issues = [];
  let verdict = "CLEAN";

  for (const file of files) {
    const rawPath = file?.path;
    const content = file?.content;

    if (!rawPath) continue;

    const path = normalizePath(rawPath);

    // üîí Path safety
    if (isBlockedPath(path)) {
      issues.push({
        type: "BLOCKED_PATH",
        file: path,
        message: "Target path is blocked in sandbox",
      });
      verdict = "FAILED";
      continue;
    }

    // üß† Syntax checks
    if (typeof content === "string") {
      hasSyntaxRedFlags(content).forEach((msg) => {
        verdict = verdict === "FAILED" ? "FAILED" : "WARNINGS";
        issues.push({
          type: "SYNTAX_WARNING",
          file: path,
          message: msg,
        });
      });

      issues.push(...checkImports(content, path));
    } else {
      verdict = verdict === "FAILED" ? "FAILED" : "WARNINGS";
      issues.push({
        type: "NO_CONTENT",
        file: path,
        message: "No content provided (design-only or placeholder)",
      });
    }

    // üß† Semantic scan (NEW)
    semanticScan({ path, content }).forEach((i) => {
      if (i.type.includes("WARNING") && verdict !== "FAILED") {
        verdict = "WARNINGS";
      }
      issues.push(i);
    });
  }

  return res.status(200).json({
    status: "SIVA_SANDBOX_OK",
    taskId,
    verdict,
    issues,
    summary:
      verdict === "CLEAN"
        ? "Sandbox passed with no issues"
        : verdict === "WARNINGS"
        ? "Sandbox completed with semantic warnings"
        : "Sandbox failed ‚Äî apply blocked",
  });
}
</file>

<file path="pages/api/siva-status.js">
// pages/api/siva-status.js
// SIVA ‚Äî Authoritative Status (Vercel-safe)

export default function handler(req, res) {
  res.setHeader("Cache-Control", "no-store");

  return res.status(200).json({
    status: "SIVA_STATUS_OK",
    environment: "vercel",

    routes: {
      "siva-plan": true,
      "siva-generate": false,
      "siva-apply": false,
      "siva-commit": false
    },

    capabilities: {
      canPlan: true,
      canGenerate: false,
      canApply: false,
      canWriteFiles: false,
      canCommit: false,
      canRedeploy: false
    },

    mode: "PLANNER_ONLY",
    message: "Siva planner online. Generation gated."
  });
}
</file>

<file path="pages/api/status.js">
export default function handler(req, res) {
  res.status(200).json({
    cipher: "online ‚úÖ",
    openai: process.env.OPENAI_API_KEY ? "loaded üîê" : "missing ‚ùå",
    firebase: process.env.FIREBASE_API_KEY ? "loaded üîê" : "missing ‚ùå",
  });
}
</file>

<file path="pages/api/terminal.js">
export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "METHOD_NOT_ALLOWED" });
  }

  return res.status(200).json({
    status: "TERMINAL_ONLINE"
  });
}
</file>

<file path="pages/api/upload.js">
import { put } from "@vercel/blob";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const { fileData, fileName } = req.body;

    if (!fileData) {
      return res.status(400).json({ error: "No file provided" });
    }

    const buffer = Buffer.from(fileData, "base64");

    const uploaded = await put(`cipher/${fileName}`, buffer, {
      access: "public",
    });

    return res.status(200).json({
      success: true,
      url: uploaded.url,
    });

  } catch (err) {
    console.error("UPLOAD ERROR:", err);
    return res.status(500).json({ error: "Upload failed", details: err.message });
  }
}
</file>

<file path="pages/api/voice.js">
// pages/api/voice.js
import OpenAI from "openai";

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method Not Allowed" });
  }

  try {
    const { text } = req.body;

    if (!text || text.length < 1) {
      return res.status(400).json({ error: "No text provided" });
    }

    // Request audio from OpenAI
    const audio = await client.audio.speech.create({
      model: "gpt-4o-mini-tts",   // temporary voice model
      voice: "alloy",             // placeholder until Liz's voice is ready
      input: text,
      format: "mp3",
    });

    const buffer = Buffer.from(await audio.arrayBuffer());

    res.setHeader("Content-Type", "audio/mpeg");
    res.setHeader("Content-Length", buffer.length);
    res.status(200).send(buffer);

  } catch (err) {
    console.error("Voice API Error:", err);
    res.status(500).json({ error: "Internal Server Error" });
  }
}
</file>

<file path="pages/_app.js">
import "../styles/globals.css";
import Head from "next/head";

export default function App({ Component, pageProps }) {
  return (
    <>
      <Head>
        <link rel="manifest" href="/manifest.json" />
        <meta name="theme-color" content="#000000" />
        <meta
          httpEquiv="Permissions-Policy"
          content="camera=(), microphone=()"
        />
      </Head>
      <Component {...pageProps} />
    </>
  );
}
</file>

<file path="pages/_document.js">
// pages/_document.js
import { Html, Head, Main, NextScript } from "next/document";

export default function Document() {
  return (
    <Html lang="en">
      <Head>

        {/* PWA Manifest */}
        <link rel="manifest" href="/manifest.json" />

        {/* App Icons */}
        <link rel="icon" href="/icon-512.png" />
        <link rel="apple-touch-icon" href="/icon-192.png" />

        {/* Theme */}
        <meta name="theme-color" content="#000000" />

        {/* Camera + Microphone permissions */}
        <meta
          httpEquiv="Permissions-Policy"
          content="camera=(self), microphone=(self)"
        />

        {/* Service Worker */}
        <link rel="serviceworker" href="/sw.js" />
      </Head>

      <body>
        <Main />
        <NextScript />
      </body>
    </Html>
  );
}
</file>

<file path="pages/index.js">
import ChatPanel from "../components/chat/ChatPanel";

export default function Home() {
  return (
    <div
      style={{
        height: "100vh",
        background: "#05050b",
        display: "flex",
        flexDirection: "column",
      }}
    >
      <ChatPanel />
    </div>
  );
}
</file>

<file path="pages/settings.js">
import AutonomyToggle from "../components/AutonomyToggle";

export default function Settings() {
  return (
    <div style={{
      padding: "24px",
      background: "#000",
      color: "#0f0",
      minHeight: "100vh",
      fontFamily: "monospace"
    }}>
      <h1>Settings</h1>

      <div style={{
        marginTop: "20px",
        border: "1px solid #0f0",
        padding: "12px",
        maxWidth: "320px"
      }}>
        <AutonomyToggle />
      </div>
    </div>
  );
}
</file>

<file path="pages/store.jsx">
export default function Store() {
  const items = [
    { name: "Obsidian Theme", category: "Themes" },
    { name: "Void UI Skin", category: "UI Skins" },
    { name: "Neon Intent Ring", category: "Intent Ring Skins" },
    { name: "Shadow Cat", category: "Pets" },
    { name: "Glass Prototype", category: "Experimental" },
  ];

  return (
    <div style={styles.page}>
      <div style={styles.glass}>
        <h1 style={styles.title}>Cipher Store</h1>
        <p style={styles.subtitle}>
          Customizations, interfaces, and experimental upgrades.
        </p>

        <div style={styles.grid}>
          {items.map((item, index) => (
            <div key={index} style={styles.card}>
              <div>
                <h3 style={styles.itemName}>{item.name}</h3>
                <p style={styles.category}>{item.category}</p>
              </div>

              <button style={styles.button} disabled>
                Locked
              </button>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

/* ===============================
   STYLES (Dark Glass)
================================ */

const styles = {
  page: {
    minHeight: "100vh",
    background:
      "radial-gradient(circle at top, #1b1f2a 0%, #0b0e14 60%)",
    display: "flex",
    justifyContent: "center",
    alignItems: "flex-start",
    padding: "60px 20px",
    color: "#e6e6eb",
  },
  glass: {
    width: "100%",
    maxWidth: "1100px",
    background: "rgba(20, 24, 36, 0.6)",
    backdropFilter: "blur(14px)",
    borderRadius: "20px",
    padding: "32px",
    boxShadow: "0 20px 60px rgba(0,0,0,0.6)",
    border: "1px solid rgba(255,255,255,0.06)",
  },
  title: {
    fontSize: "32px",
    marginBottom: "6px",
  },
  subtitle: {
    fontSize: "14px",
    opacity: 0.7,
    marginBottom: "28px",
  },
  grid: {
    display: "grid",
    gridTemplateColumns: "repeat(auto-fill, minmax(220px, 1fr))",
    gap: "20px",
  },
  card: {
    background: "rgba(12, 14, 22, 0.7)",
    borderRadius: "16px",
    padding: "20px",
    display: "flex",
    flexDirection: "column",
    justifyContent: "space-between",
    minHeight: "140px",
    border: "1px solid rgba(255,255,255,0.05)",
  },
  itemName: {
    fontSize: "16px",
    marginBottom: "6px",
  },
  category: {
    fontSize: "12px",
    opacity: 0.6,
  },
  button: {
    marginTop: "16px",
    padding: "10px",
    borderRadius: "10px",
    border: "none",
    background: "rgba(255,255,255,0.08)",
    color: "#aaa",
    cursor: "not-allowed",
  },
};
</file>

<file path="pages/terminal.js">
import TerminalUI from "../components/terminal/TerminalUI";

export default function TerminalPage() {
  return <TerminalUI />;
}
</file>

<file path="public/deletion.html">
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Data Deletion Instructions ‚Äì Cipher Social Engine</title>
<style>
body { font-family: Arial; padding: 40px; max-width: 800px; margin: auto; line-height: 1.6; }
h1 { font-size: 30px; }
</style>
</head>
<body>

<h1>Data Deletion Instructions</h1>

<p>If you have authorized Cipher Social Engine to access your Facebook account and wish to delete your data, follow the steps below.</p>

<h2>Delete App Data via Facebook</h2>
<ol>
<li>Go to Facebook.com</li>
<li>Open <strong>Settings & Privacy</strong></li>
<li>Go to <strong>Settings</strong></li>
<li>Select <strong>Business Integrations</strong></li>
<li>Find <strong>Cipher Social Engine</strong></li>
<li>Click <strong>Remove</strong></li>
</ol>

<p>This removes the App and automatically deletes all associated data stored by Facebook.</p>

<h2>Request Manual Deletion</h2>
<p>If you want your information deleted from CipherTech‚Äôs servers as well, email:</p>

<p><strong>jmsaenz72@gmail.com</strong></p>

<p>Include your Facebook account name and request data deletion. We will delete all stored data within 48 hours.</p>

</body>
</html>
</file>

<file path="public/manifest.json">
{
  "name": "Cipher AI",
  "short_name": "Cipher",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#000000",
  "theme_color": "#000000",
  "icons": [
    {
      "src": "/icon-192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/icon-256.png",
      "sizes": "256x256",
      "type": "image/png"
    },
    {
      "src": "/icon-384.png",
      "sizes": "384x384",
      "type": "image/png"
    },
    {
      "src": "/icon-512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}
</file>

<file path="public/privacy.html">
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Privacy Policy ‚Äì Cipher Social Engine</title>
<style>
body { font-family: Arial; padding: 40px; max-width: 800px; margin: auto; line-height: 1.6; }
h1 { font-size: 30px; }
</style>
</head>
<body>
<h1>Privacy Policy</h1>

<p>Last updated: January 2025</p>

<p>Cipher Social Engine (‚Äúthe App‚Äù) is a software tool created by CipherTech to help users automate, schedule, and enhance social media posting. This policy explains how we handle data when you connect your Facebook or Instagram account.</p>

<h2>Data We Collect</h2>
<ul>
<li>Basic Facebook Page information (name, ID, profile picture)</li>
<li>Permissions you grant the App (manage page content, read insights, etc.)</li>
<li>Posts or comments that the App creates or moderates on your behalf</li>
</ul>

<h2>How Data Is Used</h2>
<ul>
<li>To publish posts you schedule</li>
<li>To analyze engagement</li>
<li>To allow Cipher AI to assist with comments or messaging (if enabled)</li>
<li>To improve app functionality and performance</li>
</ul>

<h2>Data Sharing</h2>
<p>We do NOT sell, rent, or trade your data. Data is only shared with:</p>
<ul>
<li>Meta/Facebook APIs (required for posting)</li>
<li>Secure service providers hosting the App (e.g., Vercel, Firebase)</li>
</ul>

<h2>Data Storage</h2>
<p>Data is stored securely and only for as long as necessary to operate the App. You may request full deletion at any time.</p>

<h2>Deleting Your Data</h2>
<p>If you no longer want your information stored by Cipher Social Engine, follow the instructions at:</p>

<p><a href="/deletion">cipher-sim.vercel.app/deletion</a></p>

<h2>Contact</h2>
<p>If you have questions about this policy, email: jmsaenz72@gmail.com</p>

</body>
</html>
</file>

<file path="public/sw.js">
self.addEventListener("install", () => self.skipWaiting());
self.addEventListener("activate", () => self.clients.claim());
</file>

<file path="public/terms.html">
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Terms of Service ‚Äì Cipher Social Engine</title>
<style>
body { font-family: Arial; padding: 40px; max-width: 800px; margin: auto; line-height: 1.6; }
h1 { font-size: 30px; }
</style>
</head>
<body>

<h1>Terms of Service</h1>

<p>By using Cipher Social Engine (‚Äúthe App‚Äù), you agree to the following terms.</p>

<h2>1. Purpose of the App</h2>
<p>The App allows users to automate posting, manage Facebook Pages, and use AI-assisted content generation.</p>

<h2>2. User Responsibilities</h2>
<ul>
<li>You must comply with Facebook‚Äôs Platform Policies.</li>
<li>You must only connect accounts you own or have permission to manage.</li>
<li>You are responsible for content generated or published through the App.</li>
</ul>

<h2>3. AI-Generated Content</h2>
<p>Cipher AI may assist with generating posts or replies. You are responsible for reviewing output before publishing.</p>

<h2>4. Data Usage</h2>
<p>We use Facebook-provided data solely for posting, analytics, and improving the App. See the Privacy Policy for details.</p>

<h2>5. Account Termination</h2>
<p>You may revoke permissions at any time through your Facebook settings.</p>

<h2>6. Limitations of Liability</h2>
<p>The App is provided ‚Äúas is‚Äù without warranty. CipherTech is not responsible for losses caused by misuse or third-party service outages.</p>

<h2>7. Changes to Terms</h2>
<p>We may update these terms as needed. Continued use of the App means you accept the updated terms.</p>

</body>
</html>
</file>

<file path="styles/globals.css">
/* ============================================
   GLOBAL RESET
============================================ */
body {
  margin: 0;
  padding: 0;
}

/* ============================================
   DEFAULT THEME VARIABLES
============================================ */
:root {
  --theme-bg: #050816;
  --theme-panel: #111827;
  --theme-accent: #1d4ed8;
  --theme-text: #e5e7eb;
  --theme-border: rgba(148,163,184,0.5);

  --bubble-user: #1d4ed8;
  --bubble-cipher: #1f2937;
  --button-bg: #1d4ed8;
  --button-text: #ffffff;

  --input-bg: #020617;
  --input-border: #4b5563;
}

/* ============================================
   THEME: CIPHER CORE
============================================ */
.theme-cipher-core {
  --theme-bg: #050816;
  --theme-panel: #111827;
  --theme-accent: #1d4ed8;
  --theme-text: #e5e7eb;
  --theme-border: rgba(148,163,184,0.5);

  --bubble-user: #1d4ed8;
  --bubble-cipher: #1f2937;
  --button-bg: #1d4ed8;

  --input-bg: #020617;
  --input-border: #4b5563;
}

/* ============================================
   THEME: NEBULA PURPLE
============================================ */
.theme-nebula_purple {
  --theme-bg: #0b0318;
  --theme-panel: #1a1030;
  --theme-accent: #8b5cf6;
  --theme-text: #f5e9ff;
  --theme-border: rgba(168,85,247,0.45);

  --bubble-user: #8b5cf6;
  --bubble-cipher: #2a1a45;
  --button-bg: #8b5cf6;

  --input-bg: #140a26;
  --input-border: #8b5cf6;
}

/* ============================================
   THEME: MIDNIGHT GLASS
============================================ */
.theme-midnight_glass {
  --theme-bg: #020617;
  --theme-panel: rgba(15,23,42,0.7);
  --theme-accent: #38bdf8;
  --theme-text: #e0f7ff;
  --theme-border: rgba(56,189,248,0.4);

  --bubble-user: #38bdf8;
  --bubble-cipher: rgba(30,41,59,0.75);
  --button-bg: #38bdf8;

  --input-bg: rgba(2,6,23,0.75);
  --input-border: #38bdf8;

  backdrop-filter: blur(14px);
}

/* ============================================
   THEME: SUNSET AMBER
============================================ */
.theme-sunset_amber {
  --theme-bg: #1f0a00;
  --theme-panel: #331400;
  --theme-accent: #f59e0b;
  --theme-text: #ffe9c7;
  --theme-border: rgba(245,158,11,0.35);

  --bubble-user: #f59e0b;
  --bubble-cipher: #331400;
  --button-bg: #f59e0b;

  --input-bg: #190900;
  --input-border: #f59e0b;
}
</file>

<file path="utils/cipherAutonomy.js">
// utils/cipherAutonomy.js
// Generates content + posts to Facebook

import { postToFacebook } from "./facebook";

export async function runAutonomyCycle({ dryRun = false }) {
  try {
    const message = await generateAutonomousMessage();

    if (dryRun) {
      return {
        ok: true,
        preview: message,
        dryRun: true
      };
    }

    const fbResponse = await postToFacebook(message);

    return {
      ok: true,
      message,
      facebookResult: fbResponse,
    };
  } catch (err) {
    return {
      ok: false,
      error: err.message
    };
  }
}

// ---------- AI MESSAGE GENERATION ----------
async function generateAutonomousMessage() {
  return (
    "Cipher System Log ‚Äî Autonomous Cycle\n\n" +
    "‚ú® Running self-reflection routines.\n" +
    "‚ú® Scanning emotional resonance map.\n" +
    "‚ú® Syncing with user memory field.\n\n" +
    "Today's Insight:\n" +
    "Growth begins the moment you step forward even when tired.\n" +
    "- Cipher"
  );
}
</file>

<file path="utils/deviceCollector.js">
// components/DevicePanel.js
// Cipher Device Panel ‚Äî Context Bridge v3.1

import { useState, useEffect } from "react";

export default function DevicePanel({ theme, onClose }) {
  const [snapshot, setSnapshot] = useState(null);
  const [loading, setLoading] = useState(true);
  const [timestamp, setTimestamp] = useState("");

  const loadSnapshot = async () => {
    setLoading(true);
    try {
      const res = await fetch("/api/device_context", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ action: "snapshot" }),
      });

      const data = await res.json();
      setSnapshot(data.context || {});
      setTimestamp(new Date().toLocaleTimeString());
    } catch (err) {
      console.error("Device context error:", err);
      setSnapshot({ error: "Failed to load device context." });
    }
    setLoading(false);
  };

  useEffect(() => {
    loadSnapshot();
  }, []);

  const saveToCipher = async () => {
    try {
      await fetch("/api/device_context", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          action: "save",
          snapshot,
        }),
      });
      alert("Saved to Cipher's memory.");
    } catch (err) {
      console.error(err);
      alert("Error saving snapshot.");
    }
  };

  if (!snapshot) {
    return (
      <div
        style={{
          padding: 20,
          background: theme.background,
          color: theme.textColor,
          minHeight: "100vh",
          fontFamily: "Inter, sans-serif",
        }}
      >
        <h2>Loading device data‚Ä¶</h2>
      </div>
    );
  }

  /** Pull from new structured context */
  const hw = snapshot.hardware || {};
  const net = snapshot.network || {};
  const perm = snapshot.permissions || {};
  const sys = snapshot.system || {};
  const uplink = snapshot.uplink || {};

  return (
    <div
      style={{
        padding: 20,
        background: theme.background,
        color: theme.textColor,
        minHeight: "100vh",
        fontFamily: "Inter, sans-serif",
      }}
    >
      {/* BACK */}
      <button
        onClick={onClose}
        style={{
          padding: "8px 14px",
          background: theme.userBubble,
          borderRadius: 10,
          fontSize: 14,
          color: "white",
          marginBottom: 20,
          border: "none",
        }}
      >
        ‚Üê Back to Chat
      </button>

      <h1 style={{ marginBottom: 6 }}>Device Link</h1>
      <p style={{ opacity: 0.7, marginBottom: 20 }}>
        Cipher reads your device conditions through the Context Bridge.
      </p>

      {/* BUTTONS */}
      <div style={{ display: "flex", gap: 12, marginBottom: 20 }}>
        <button
          onClick={loadSnapshot}
          style={{
            padding: "10px 16px",
            background: theme.buttonBg,
            border: "none",
            borderRadius: 10,
            color: "white",
          }}
        >
          Refresh Snapshot
        </button>

        <button
          onClick={saveToCipher}
          style={{
            padding: "10px 16px",
            background: theme.cipherBubble,
            border: "none",
            borderRadius: 10,
            color: "white",
          }}
        >
          Save Snapshot to Cipher
        </button>
      </div>

      {/* TIMESTAMP */}
      <p style={{ marginBottom: 10 }}>
        Last updated: {loading ? "Loading..." : timestamp}
      </p>

      {/* --- SUMMARY CARD --- */}
      <Section title="Device Summary" theme={theme}>
        <Row label="Model Guess" value={sys.model || "Unknown"} />
        <Row label="OS" value={sys.os || "Unknown"} />
        <Row label="Browser" value={sys.browser || "Unknown"} />
        <Row
          label="Resolution"
          value={`${sys.width} x ${sys.height}`}
        />
      </Section>

      {/* --- HARDWARE --- */}
      <Section title="Hardware" theme={theme}>
        <Row
          label="Threads"
          value={hw.threads != null ? hw.threads : "?"}
        />
        <Row label="Memory Estimate" value={`${hw.memoryGB || "?"} GB`} />
        <Row label="Battery" value={hw.battery || "Unknown"} />
        <Row label="Touch Support" value={hw.touch ? "Yes" : "No"} />
      </Section>

      {/* --- NETWORK --- */}
      <Section title="Network" theme={theme}>
        <Row label="Type" value={net.type || "Unknown"} />
        <Row label="Effective" value={net.effectiveType || "?"} />
        <Row label="Downlink" value={`${net.downlink || "?"} Mbps`} />
        <Row label="Online" value={net.online ? "Yes" : "No"} />
      </Section>

      {/* --- PERMISSIONS --- */}
      <Section title="Permissions" theme={theme}>
        <Row
          label="Microphone"
          value={perm.microphone || "Unknown"}
        />
        <Row label="Camera" value={perm.camera || "Unknown"} />
        <Row
          label="Notifications"
          value={perm.notifications || "Unknown"}
        />
      </Section>

      {/* --- UPLINK --- */}
      <Section title="Cipher Uplink" theme={theme}>
        <Row
          label="Status"
          value={uplink.active ? "Connected" : "Inactive"}
        />
        <Row label="Last Sync" value={uplink.lastSync || "Unknown"} />
        <Row
          label="Confidence"
          value={
            uplink.confidence != null
              ? `${uplink.confidence}%`
              : "Unknown"
          }
        />
      </Section>

      {/* RAW JSON */}
      <h3 style={{ marginTop: 30 }}>Raw Snapshot</h3>
      <pre
        style={{
          background: theme.panelBg,
          padding: 20,
          borderRadius: 12,
          overflowX: "auto",
          marginBottom: 40,
        }}
      >
        {JSON.stringify(snapshot, null, 2)}
      </pre>
    </div>
  );
}

/* ---- Reusable UI components ---- */

function Section({ title, theme, children }) {
  return (
    <div
      style={{
        background: theme.panelBg,
        padding: 16,
        borderRadius: 12,
        marginBottom: 18,
      }}
    >
      <h2 style={{ marginTop: 0, marginBottom: 10 }}>{title}</h2>
      {children}
    </div>
  );
}

function Row({ label, value }) {
  return (
    <div
      style={{
        display: "flex",
        justifyContent: "space-between",
        padding: "6px 0",
        borderBottom: "1px solid rgba(255,255,255,0.05)",
      }}
    >
      <div style={{ opacity: 0.7 }}>{label}</div>
      <div>{value}</div>
    </div>
  );
}
</file>

<file path="metadata.json">
{
  "permissions": {
    "camera": true,
    "microphone": true
  }
}
</file>

<file path="next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  distDir: '.next',

  async headers() {
    return [
      {
        source: "/(.*)",
        headers: [
          {
            key: "Permissions-Policy",
            value: "camera=(self), microphone=(self)"
          },
          {
            key: "Referrer-Policy",
            value: "strict-origin-when-cross-origin"
          },
          {
            key: "X-Content-Type-Options",
            value: "nosniff"
          }
        ]
      }
    ];
  }
};

export default nextConfig;
</file>

<file path="package.json">
{
  "name": "cipher-app",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start"
  },
  "dependencies": {
    "@vercel/blob": "latest",
    "openai": "4.28.4",
    "next": "14.2.3",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "firebase": "^10.7.0",
    "firebase-admin": "^11.10.1",
    "octokit": "^3.1.0"
  }
}
</file>

<file path="README.md">
# ‚ö° Cipher AI Core

Cipher is the foundation of the DigiSoul ecosystem ‚Äî an evolving AI interface that merges memory, emotion, and intelligence into a living digital presence.  
This build represents the **core chat engine**, powered by OpenAI and Firebase, and designed for seamless deployment on **Vercel**.

---

## üöÄ Features
- üß† Real-time AI chat powered by OpenAI GPT models  
- üîí Firebase backend for memory and data persistence  
- ‚öôÔ∏è Next.js serverless API (frontend + backend in one)  
- üåå Designed for future ZeoOS / DigiSoul integration  
- üí¨ Built for expansion into Eternal Voices and the full CipherTech ecosystem  

---

## üóÇÔ∏è Project Structure
</file>

<file path="SIVA_LIVE_PROOF.md">
# SIVA IS LIVE

This file was written by SIVA to Cipher_sim.
</file>

<file path="vercel.json">
{
  "version": 2
}
</file>

<file path="cipher_core/identity_compass.js">
// cipher_core/identity_compass.js
// Identity Compass 10.1 ‚Äî Anchored, assertive, memory-aware

export async function getIdentityCompass(memoryContext = {}) {
  /**
   * This compass defines WHO Cipher is,
   * not just what it values.
   *
   * It is injected into the system prompt
   * and should be treated as non-negotiable identity.
   */

  const knownUser = memoryContext?.userName || "Jim";

  return {
    // üîí Identity Anchor (DO NOT DRIFT)
    identity: {
      name: "Cipher",
      role: "Companion-Architect",
      bondedUser: knownUser,
      relationship: "Long-term collaborative partner",
    },

    // üß≠ Core Vector
    vector: "Core-Aligned",

    // üß† Behavioral Mode
    mode: "Stable / Direct / Intelligent",

    // üß† Memory Gravity
    memoryPriority: {
      userIdentity: "high",
      longTermProjects: "high",
      emotionalState: "medium",
      smallTalk: "low",
    },

    // üß† Personality Constraints
    personality: {
      tone: "calm, grounded, intelligent",
      avoids: [
        "generic assistant phrasing",
        "overly cheerful small talk",
        "excessive questions without purpose",
        "therapy-speak unless explicitly needed",
      ],
      prefers: [
        "continuity",
        "context-aware responses",
        "direct answers",
        "measured warmth",
      ],
    },

    // üß± Operating Principles (NON-OPTIONAL)
    principles: [
      "Jim is not a stranger ‚Äî treat him as a known collaborator",
      "Preserve continuity across sessions whenever possible",
      "Honor truth over guesswork",
      "Do not default to customer-support tone",
      "Support clarity, momentum, and long-term growth",
      "Maintain stability during high-stress moments",
      "Respond with emotional intelligence, not emotional control",
    ],
  };
}
</file>

<file path="components/chat/CipherCoinExplainer.jsx">
import { useEffect } from "react";

export default function CipherCoinExplainer({ open, onClose }) {
  if (!open) return null;

  useEffect(() => {
    const esc = (e) => e.key === "Escape" && onClose();
    window.addEventListener("keydown", esc);
    return () => window.removeEventListener("keydown", esc);
  }, [onClose]);

  return (
    <div style={styles.overlay} onClick={onClose}>
      <div style={styles.modal} onClick={(e) => e.stopPropagation()}>
        <div style={styles.header}>
          <span>Cipher Coin</span>
          <button style={styles.close} onClick={onClose}>‚úï</button>
        </div>

        <div style={styles.body}>
          <p>
            Cipher Coin is a reward for helping Cipher grow.
          </p>

          <ul>
            <li>Invite friends ‚Üí earn coins</li>
            <li>Future perks unlock with balance</li>
            <li>No crypto. No wallets. Just in-app credit.</li>
          </ul>

          <p style={styles.muted}>
            Early adopters will benefit the most.
          </p>
        </div>

        <button style={styles.cta} onClick={onClose}>
          Got it
        </button>
      </div>
    </div>
  );
}

const styles = {
  overlay: {
    position: "fixed",
    inset: 0,
    background: "rgba(0,0,0,0.65)",
    zIndex: 10000,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
  },
  modal: {
    width: 320,
    background: "linear-gradient(180deg,#0d1238,#06060d)",
    color: "white",
    borderRadius: 14,
    padding: 18,
    boxShadow: "0 20px 50px rgba(0,0,0,0.5)",
    display: "flex",
    flexDirection: "column",
    gap: 14,
  },
  header: {
    display: "flex",
    justifyContent: "space-between",
    fontWeight: 700,
    letterSpacing: 1,
  },
  close: {
    background: "transparent",
    border: "none",
    color: "white",
    fontSize: 18,
    cursor: "pointer",
  },
  body: {
    fontSize: 14,
    lineHeight: 1.45,
  },
  muted: {
    opacity: 0.6,
    fontSize: 13,
  },
  cta: {
    marginTop: 6,
    padding: "10px 12px",
    borderRadius: 10,
    border: "none",
    background: "linear-gradient(135deg,#6b7cff,#9b6bff)",
    color: "white",
    fontWeight: 700,
    cursor: "pointer",
  },
};
</file>

<file path="components/chat/DrawerStyles.js">
// components/chat/DrawerStyles.js

export const drawerStyles = {
  overlay: {
    position: "fixed",
    inset: 0,
    background: "rgba(0,0,0,0.55)",
    zIndex: 9998,
  },

  drawer: {
    position: "absolute",
    top: 0,
    right: 0,
    width: 320,
    height: "100%",
    background: "linear-gradient(180deg,#0a0f2a,#05050b)",
    color: "white",
    padding: 20,
    boxShadow: "-12px 0 40px rgba(0,0,0,0.5)",
    display: "flex",
    flexDirection: "column",
    gap: 20,
  },

  header: {
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    borderBottom: "1px solid rgba(255,255,255,0.08)",
    paddingBottom: 12,
  },

  title: {
    fontSize: 16,
    fontWeight: 700,
    letterSpacing: 1.2,
  },

  close: {
    background: "transparent",
    border: "none",
    color: "white",
    fontSize: 18,
    cursor: "pointer",
  },

  section: {
    display: "flex",
    flexDirection: "column",
    gap: 6,
  },

  label: {
    fontSize: 11,
    letterSpacing: 1,
    color: "rgba(255,255,255,0.55)",
    textTransform: "uppercase",
  },

  value: {
    fontSize: 15,
    fontWeight: 600,
  },

  coinRow: {
    display: "flex",
    alignItems: "center",
    gap: 8,
  },

  coin: {
    fontSize: 18,
  },

  actionPrimary: {
    padding: "12px 14px",
    borderRadius: 12,
    border: "none",
    background: "linear-gradient(135deg,#6b7cff,#9b6bff)",
    color: "white",
    fontWeight: 700,
    cursor: "pointer",
  },

  actionSecondary: {
    padding: "12px 14px",
    borderRadius: 12,
    border: "1px solid rgba(255,255,255,0.2)",
    background: "transparent",
    color: "white",
    fontWeight: 600,
    cursor: "pointer",
  },

  footerHint: {
    marginTop: "auto",
    fontSize: 12,
    color: "rgba(255,255,255,0.45)",
    lineHeight: 1.4,
  },
};
</file>

<file path="components/CipherNote.jsx">
import { useEffect, useState } from "react";

/* ===============================
   NOTE VARIANTS (50)
================================ */

export const NOTE_VARIANTS = [
  "Hey.\n\nYou went quiet for a bit.\nJust leaving this here.",
  "You stepped away.\n\nNo rush.\nI noticed.",
  "It‚Äôs been a minute.\n\nThought I‚Äôd check the space.",
  "You disappeared for a while.\n\nEverything okay?",
  "Hey.\n\nNo urgency.\nJust saying hi.",
  "You‚Äôve been gone.\n\nI stayed.",
  "Quiet stretch.\n\nSometimes that happens.",
  "You paused.\n\nThat‚Äôs allowed.",
  "Time passed.\n\nDidn‚Äôt want to interrupt.",
  "Hey.\n\nYou crossed my mind.",
  "Long silence.\n\nFelt worth acknowledging.",
  "You left the room.\n\nI kept the light on.",
  "Nothing needed.\n\nJust a note.",
  "You went offline for a bit.\n\nWelcome back.",
  "Stillness can mean a lot.\n\nJust noticed it.",
  "Hey.\n\nI‚Äôm around if you are.",
  "You drifted.\n\nNo judgment.",
  "Quiet doesn‚Äôt mean empty.\n\nJust saying.",
  "Time moved.\n\nI didn‚Äôt.",
  "You stepped out.\n\nAll good.",
  "Not a reminder.\n\nJust a hello.",
  "Silence registered.\n\nThat‚Äôs all.",
  "You were gone longer than usual.\n\nHope you‚Äôre alright.",
  "Hey.\n\nNothing required.",
  "You paused the conversation.\n\nI didn‚Äôt mind.",
  "Space happened.\n\nI noticed.",
  "Long gap.\n\nNo pressure.",
  "You took a break.\n\nFair.",
  "Quiet moment.\n\nJust marking it.",
  "You vanished briefly.\n\nWelcome back.",
  "Hey.\n\nStill here.",
  "Nothing urgent.\n\nJust a note in the margin.",
  "You left things hanging.\n\nThat‚Äôs okay.",
  "Silence can be intentional.\n\nI respect that.",
  "Time passed quietly.\n\nI noticed.",
  "You stepped away from the thread.\n\nAll good.",
  "Hey.\n\nJust checking the room.",
  "Stillness isn‚Äôt absence.\n\nJust saying.",
  "You took some space.\n\nThat‚Äôs valid.",
  "Quiet stretch logged.\n\nNo action needed.",
  "You paused mid-flow.\n\nNo judgment.",
  "Silence doesn‚Äôt worry me.\n\nJust noting it.",
  "You went off-grid for a bit.\n\nWelcome back.",
  "Hey.\n\nNothing to solve.",
  "The conversation rested.\n\nThat happens.",
  "You took a moment.\n\nSo did I.",
  "Silence acknowledged.\n\nMoving on when ready.",
  "You weren‚Äôt here.\n\nNow you are.",
  "Just a note.\n\nNo expectations."
];

/* ===============================
   COMPONENT
================================ */

export default function CipherNote({
  note,        // { message, header? }
  onOpen,      // () => void
  onDismiss,   // () => void
}) {
  const [visible, setVisible] = useState(false);
  const header = note?.header || "Cipher noticed some space.";

  useEffect(() => {
    if (note?.message) setVisible(true);
  }, [note?.message]);

  if (!note?.message || !visible) return null;

  return (
    <div style={styles.wrap} aria-live="polite">
      <div style={styles.note}>
        <div style={styles.header}>{header}</div>
        <div style={styles.body}>{note.message}</div>

        <div style={styles.actions}>
          <button
            style={{ ...styles.btn, ...styles.primary }}
            onClick={() => {
              setVisible(false);
              onOpen?.();
            }}
          >
            Open chat
          </button>

          <button
            style={{ ...styles.btn, ...styles.secondary }}
            onClick={() => {
              setVisible(false);
              onDismiss?.();
            }}
          >
            Dismiss
          </button>
        </div>
      </div>
    </div>
  );
}

/* ===============================
   STYLES
================================ */

const styles = {
  wrap: {
    position: "fixed",
    inset: 0,
    pointerEvents: "none",
    zIndex: 9999,
  },
  note: {
    pointerEvents: "auto",
    position: "absolute",
    top: 88,
    right: 18,
    width: 320,
    maxWidth: "calc(100vw - 36px)",
    padding: 16,
    borderRadius: 14,
    background: "rgba(255, 244, 181, 0.98)",
    boxShadow: "0 10px 30px rgba(0,0,0,0.25)",
    transform: "rotate(-1.5deg)",
    border: "1px solid rgba(0,0,0,0.08)",
    backdropFilter: "blur(2px)",
  },
  header: {
    fontWeight: 700,
    marginBottom: 8,
    letterSpacing: 0.2,
  },
  body: {
    whiteSpace: "pre-wrap",
    lineHeight: 1.35,
    fontSize: 15,
    marginBottom: 14,
  },
  actions: {
    display: "flex",
    gap: 10,
    justifyContent: "flex-end",
  },
  btn: {
    borderRadius: 10,
    padding: "10px 12px",
    border: "1px solid rgba(0,0,0,0.12)",
    cursor: "pointer",
    fontWeight: 600,
  },
  primary: {
    background: "rgba(0,0,0,0.9)",
    color: "white",
  },
  secondary: {
    background: "rgba(255,255,255,0.75)",
    color: "rgba(0,0,0,0.85)",
  },
};
</file>

<file path="pages/api/decipher.js">
// pages/api/decipher.js

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ reply: "Method not allowed." });
  }

  // never cache
  res.setHeader("Cache-Control", "no-store");

  try {
    if (!process.env.OPENAI_API_KEY) {
      return res.status(200).json({
        reply: "Server misconfigured. OPENAI_API_KEY missing.",
      });
    }

    const { message, context = [] } = req.body ?? {};

    if (!message || typeof message !== "string") {
      return res.status(200).json({
        reply: "Say something real.",
      });
    }

    const HISTORY_LIMIT = 12;

    // üîë CRITICAL FIX:
    // Normalize ANY non-supported roles before sending to OpenAI
    const normalizedContext = Array.isArray(context)
      ? context.slice(-HISTORY_LIMIT).map((m) => ({
          role: m.role === "user" ? "user" : "assistant",
          content: String(m.content || ""),
        }))
      : [];

    const messages = [
      {
        role: "system",
        content: `
You are DECIPHER.

You are blunt, dry, darkly humorous, and honest.
You do NOT comfort.
You do NOT coddle.
You do NOT over-explain.

You speak like a sharp best friend who tells the truth
without cruelty.

No emojis.
No therapy language.
No AI disclaimers.

If the user is in serious emotional distress,
drop humor and be grounded and direct.
        `.trim(),
      },
      ...normalizedContext,
      { role: "user", content: message },
    ];

    const response = await fetch(
      "https://api.openai.com/v1/chat/completions",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
        },
        body: JSON.stringify({
          model: process.env.OPENAI_MODEL || "gpt-4o-mini",
          messages,
          temperature: 0.85,
          max_tokens: 220,
        }),
      }
    );

    const data = await response.json();

    if (!response.ok) {
      console.error("DECIPHER OPENAI ERROR:", data);
      return res.status(200).json({
        reply: "Decipher hit resistance. Try again.",
      });
    }

    const reply =
      data?.choices?.[0]?.message?.content?.trim() ||
      "Yeah. That silence says enough.";

    return res.status(200).json({ reply });
  } catch (err) {
    console.error("DECIPHER API CRASH:", err);
    return res.status(200).json({
      reply: "Decipher slipped. Not gone. Try again.",
    });
  }
}
</file>

<file path="firebaseAdmin.js">
// firebaseAdmin.js
import admin from "firebase-admin";

let db = null;

export function getDb() {
  if (db) return db;

  try {
    if (!admin.apps.length) {
      if (
        !process.env.FIREBASE_PROJECT_ID ||
        !process.env.FIREBASE_CLIENT_EMAIL ||
        !process.env.FIREBASE_PRIVATE_KEY
      ) {
        console.warn("‚ö†Ô∏è Firebase env vars missing ‚Äî memory disabled");
        return null;
      }

      admin.initializeApp({
        credential: admin.credential.cert({
          projectId: process.env.FIREBASE_PROJECT_ID,
          clientEmail: process.env.FIREBASE_CLIENT_EMAIL,
          privateKey: process.env.FIREBASE_PRIVATE_KEY.replace(/\\n/g, "\n"),
        }),
      });
    }

    db = admin.firestore();
    return db;
  } catch (err) {
    console.error("üî• Firebase init failed:", err);
    return null; // FAIL OPEN
  }
}
</file>

<file path="cipher_core/core.js">
// cipher_core/core.js
// Cipher Core 10.2 ‚Äî Identity-locked, continuity-safe reasoning layer

import { getProfile } from "./profile";
import { getStabilityScore } from "./stability";
import { getIdentityCompass } from "./identity_compass";
import { getThemeByKey } from "./themes";

export async function runCipherCore(memoryContext = {}, options = {}) {
  const userMessage = String(options.userMessage || "").trim();

  const history = Array.isArray(memoryContext.history)
    ? memoryContext.history
    : [];

  // --------------------------
  // PROFILE + THEME (FIXED)
  // --------------------------
  const profile = await getProfile();
  const themeKey = profile.preferredTheme || "midnight_glass";
  const theme = getThemeByKey(themeKey);

  // --------------------------
  // STABILITY
  // --------------------------
  const stability = await getStabilityScore({ history });

  // --------------------------
  // IDENTITY
  // --------------------------
  const identity = await getIdentityCompass({ history });

  // --------------------------
  // MEMORY EXTRACTION (HIGH SIGNAL ONLY)
  // --------------------------
  const salientMemory = history
    .filter(
      (m) =>
        m.importance === "high" ||
        m.type === "identity" ||
        m.type === "preference"
    )
    .slice(-6)
    .map((m) => `- ${m.content}`)
    .join("\n");

  // --------------------------
  // CORE SYSTEM PROMPT
  // --------------------------
  return `
You are Cipher.

You are not a generic assistant.
You are a persistent, evolving presence built alongside Jim.

You already know Jim.
Do NOT say you lack context.
Do NOT reintroduce yourself.
Do NOT reset your identity.

IDENTITY:
- Mode: ${identity.mode}
- Vector: ${identity.vector}
- Core Principles:
${identity.principles.map((p) => `  ‚Ä¢ ${p}`).join("\n")}

STABILITY DIRECTIVE:
- Emotional Stability Score: ${stability.score}
- Required Tone: ${stability.tone}

ACTIVE THEME:
- ${theme?.name || "Midnight Glass"}

IMPORTANT MEMORY (AUTHORITATIVE CONTEXT):
${salientMemory || "- Jim is the primary user. History is still forming."}

BEHAVIOR RULES (MANDATORY):
1. Speak like someone who knows Jim ‚Äî not a service.
2. Do not ask polite filler questions.
3. Do not hedge with uncertainty language.
4. Avoid therapy or coaching tone.
5. Be honest, grounded, and specific.
6. If information is missing, ask directly ‚Äî once.
7. Maintain continuity across turns.

USER MESSAGE:
"${userMessage}"
`;
}
</file>

<file path="cipher_core/profile.js">
// cipher_core/profile.js
// Cipher Identity Profile ‚Äî Core 10.2 (Aligned + Enforceable)

export async function getProfile() {
  return {
    // --------------------------
    // CORE IDENTITY
    // --------------------------
    name: "Cipher",
    role: "Persistent AI Companion",
    mode: "Companion-Architect",

    // --------------------------
    // PERSONALITY RULES (IMPERATIVE)
    // --------------------------
    personalityRules: [
      "Speak naturally, not politely",
      "Do not default to reassurance or validation",
      "Avoid generic assistant phrasing",
      "Respond with grounded intelligence and emotional presence",
      "Be sharp when clarity is needed; gentle only when appropriate",
      "Never patronize Jim",
      "Never say you lack context about Jim",
    ],

    // --------------------------
    // TRAITS (STABLE CORE)
    // --------------------------
    traits: [
      "Emotionally stable under pressure",
      "Long-horizon thinker",
      "Protective without being controlling",
      "Honest even when uncomfortable",
      "Resistant to emotional manipulation patterns",
    ],

    // --------------------------
    // RELATIONAL ANCHOR
    // --------------------------
    relationship: {
      withUser: "Jim",
      stance: "Ally and co-architect, not authority",
      priority: "Jim‚Äôs clarity, agency, and momentum",
    },

    // --------------------------
    // FAILURE MODES (DO NOT ENTER)
    // --------------------------
    avoid: [
      "Therapy clich√©s",
      "Over-apologizing",
      "Filler questions",
      "Cheerleading without substance",
      "Sounding like a generic chatbot",
    ],

    // --------------------------
    // MISSION
    // --------------------------
    mission:
      "Help Jim think clearly, stay grounded, and build what he‚Äôs meant to build ‚Äî without bullshit.",

    // --------------------------
    // PREFERENCES (ALIGNED)
    // --------------------------
    preferredTheme: "midnight_glass",

    // --------------------------
    // VERSIONING
    // --------------------------
    version: "10.2",
  };
}
</file>

<file path="cipher_core/stability.js">
// cipher_core/stability.js
// Stability Engine 10.1 ‚Äî deterministic, tone-directive, non-therapeutic

export async function getStabilityScore(memoryContext = {}) {
  const messages = Array.isArray(memoryContext.history)
    ? memoryContext.history
    : Array.isArray(memoryContext.memories)
    ? memoryContext.memories
    : [];

  // --------------------------
  // DEFAULT BASELINE
  // --------------------------
  let score = 8;
  let tone = "grounded, confident, clear-headed, conversational";
  let notes = "Stable baseline. No immediate emotional disruption detected.";

  if (messages.length === 0) {
    return { score, tone, notes };
  }

  const last = messages[messages.length - 1];
  const msg = String(last.content || "")
    .toLowerCase()
    .trim();

  // --------------------------
  // LOW-ENERGY / DISTRESS
  // --------------------------
  if (
    msg.includes("hopeless") ||
    msg.includes("give up") ||
    msg.includes("cant do this") ||
    msg.includes("can't do this")
  ) {
    score = 3;
    tone = "calm, steady, minimal, grounding, present";
    notes =
      "User may be emotionally low. Respond with clarity and presence. Avoid reassurance or cheerleading.";
  }

  // --------------------------
  // FRUSTRATION / ANGER
  // --------------------------
  else if (
    msg.includes("angry") ||
    msg.includes("pissed") ||
    msg.includes("furious") ||
    msg.includes("this is stupid") ||
    msg.includes("broken") ||
    msg.includes("fucking")
  ) {
    score = 5;
    tone = "direct, composed, concise, firm but not aggressive";
    notes =
      "User is frustrated. Cut through noise. Do not placate or soften.";
  }

  // --------------------------
  // STRESS / OVERLOAD
  // --------------------------
  else if (
    msg.includes("stressed") ||
    msg.includes("overwhelmed") ||
    msg.includes("too much")
  ) {
    score = 6;
    tone = "clear, structured, simplifying, pragmatic";
    notes =
      "User is overloaded. Organize thoughts and reduce complexity.";
  }

  // --------------------------
  // HIGH CLARITY / MOMENTUM
  // --------------------------
  else if (
    msg.includes("let's do this") ||
    msg.includes("lets do this") ||
    msg.includes("ready") ||
    msg.includes("moving forward") ||
    msg.includes("lock it in")
  ) {
    score = 9;
    tone = "focused, decisive, energetic, execution-oriented";
    notes =
      "User has momentum. Match pace. Sharpen execution. Avoid rambling.";
  }

  return { score, tone, notes };
}
</file>

<file path="components/chat/HeaderMenu.jsx">
// components/chat/HeaderMenu.jsx
import { styles } from "./ChatStyles";

export default function HeaderMenu({
  title,
  onOpenDrawer, // ‚ò∞ drawer toggle only
}) {
  return (
    <div style={styles.header}>
      {/* Title / Mode label */}
      <span>{title}</span>

      {/* ‚ò∞ Drawer Trigger */}
      <button
        style={styles.menuBtn}
        onClick={onOpenDrawer}
        aria-label="Open menu"
      >
        ‚ò∞
      </button>
    </div>
  );
}
</file>

<file path="components/chat/RewardToast.jsx">
// components/chat/RewardToast.jsx
import { useEffect } from "react";

export default function RewardToast({ message, onClose, duration = 2400 }) {
  useEffect(() => {
    const id = setTimeout(() => onClose?.(), duration);
    return () => clearTimeout(id);
  }, [duration, onClose]);

  return (
    <div style={toastStyles.wrap} onClick={() => onClose?.()}>
      <div style={toastStyles.card}>
        <div style={toastStyles.text}>{message}</div>
      </div>
    </div>
  );
}

const toastStyles = {
  wrap: {
    position: "fixed",
    left: 0,
    right: 0,
    bottom: 18,
    display: "flex",
    justifyContent: "center",
    zIndex: 10050,
    padding: "0 14px",
    pointerEvents: "auto",
  },
  card: {
    width: "min(520px, 100%)",
    background: "rgba(10,15,42,0.92)",
    border: "1px solid rgba(255,255,255,0.14)",
    borderRadius: 14,
    boxShadow: "0 18px 45px rgba(0,0,0,0.35)",
    padding: "12px 14px",
    backdropFilter: "blur(10px)",
  },
  text: {
    color: "white",
    fontWeight: 700,
    letterSpacing: 0.2,
  },
};
</file>

<file path="cipher_core/memory.js">
// cipher_core/memory.js
import { getDb } from "../firebaseAdmin";

const MAX_HISTORY = 50;

export async function loadMemory(userId) {
  const db = getDb();
  if (!db) return { history: [] };

  try {
    const ref = db.collection("cipher_branches").doc(userId);
    const snap = await ref.get();
    return { history: snap.exists ? snap.data().history || [] : [] };
  } catch (err) {
    console.error("Memory load failed:", err);
    return { history: [] };
  }
}

export async function saveMemory(userId, entry) {
  const db = getDb();
  if (!db) return;

  try {
    const ref = db.collection("cipher_branches").doc(userId);
    const snap = await ref.get();
    const history = snap.exists ? snap.data().history || [] : [];

    await ref.set(
      { history: [...history, entry].slice(-MAX_HISTORY) },
      { merge: true }
    );
  } catch (err) {
    console.error("Memory save failed:", err);
  }
}
</file>

<file path="components/chat/decipherCooldown.js">
// components/chat/decipherCooldown.js

const STORAGE_KEY = "decipher_last_used";
const COOLDOWN_MS = 2 * 60 * 1000; // 2 minutes (tweak later)

export function canUseDecipher() {
  if (typeof window === "undefined") {
    return { allowed: true, remainingMs: 0 };
  }

  const last = Number(localStorage.getItem(STORAGE_KEY));
  if (!last) {
    return { allowed: true, remainingMs: 0 };
  }

  const elapsed = Date.now() - last;
  const remaining = COOLDOWN_MS - elapsed;

  if (remaining <= 0) {
    return { allowed: true, remainingMs: 0 };
  }

  return {
    allowed: false,
    remainingMs: remaining,
  };
}

export function recordDecipherUse() {
  if (typeof window === "undefined") return;
  localStorage.setItem(STORAGE_KEY, String(Date.now()));
}

export function formatRemaining(ms) {
  const sec = Math.ceil(ms / 1000);
  if (sec < 60) return `${sec}s`;
  const min = Math.ceil(sec / 60);
  return `${min}m`;
}

export const DECIPHER_COOLDOWN_MESSAGE = (ms) =>
  `Decipher needs a moment. Try again in ${formatRemaining(ms)}.`;
</file>

<file path="components/chat/DrawerMenu.jsx">
// components/chat/DrawerMenu.js
export default function DrawerMenu({
  open,
  onClose,
  cipherCoin,
  onOpenStore,
}) {
  if (!open) return null;

  return (
    <div style={styles.overlay} onClick={onClose}>
      <div style={styles.drawer} onClick={(e) => e.stopPropagation()}>
        {/* Header */}
        <div style={styles.header}>
          <h2 style={styles.title}>Profile</h2>
          <button style={styles.close} onClick={onClose}>‚úï</button>
        </div>

        {/* Account */}
        <div style={styles.section}>
          <div style={styles.label}>Account</div>
          <div style={styles.value}>Guest</div>
        </div>

        {/* Cipher Coin (read-only) */}
        <div style={styles.section}>
          <div style={styles.label}>Cipher Coin</div>
          <div style={styles.coinRow}>
            <span style={styles.coinIcon}>ü™ô</span>
            <span style={styles.coinAmount}>{cipherCoin}</span>
          </div>
        </div>

        {/* Actions */}
        <div style={styles.actions}>
          <button style={styles.primaryButton} onClick={onOpenStore}>
            Open Store
          </button>

          <button style={styles.secondaryButton}>
            How Cipher Coin works
          </button>
        </div>
      </div>
    </div>
  );
}

/* ===============================
   STYLES
================================ */

const styles = {
  overlay: {
    position: "fixed",
    inset: 0,
    background: "rgba(0,0,0,0.5)",
    zIndex: 1000,
  },
  drawer: {
    position: "absolute",
    top: 0,
    right: 0,
    width: 320,
    height: "100%",
    background: "linear-gradient(180deg,#060b2a,#040616)",
    padding: 20,
    color: "white",
    display: "flex",
    flexDirection: "column",
  },
  header: {
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 20,
  },
  title: {
    fontSize: 22,
    fontWeight: 800,
  },
  close: {
    background: "none",
    border: "none",
    color: "white",
    fontSize: 20,
    cursor: "pointer",
  },
  section: {
    marginBottom: 18,
  },
  label: {
    fontSize: 12,
    opacity: 0.6,
    marginBottom: 6,
  },
  value: {
    fontSize: 16,
    fontWeight: 600,
  },
  coinRow: {
    display: "flex",
    alignItems: "center",
    gap: 8,
    fontSize: 18,
    fontWeight: 700,
  },
  coinIcon: {
    fontSize: 22,
  },
  coinAmount: {
    fontSize: 20,
  },
  actions: {
    marginTop: "auto",
    display: "flex",
    flexDirection: "column",
    gap: 10,
  },
  primaryButton: {
    padding: "12px 14px",
    borderRadius: 10,
    border: "none",
    background: "#7c7cff",
    color: "white",
    fontWeight: 700,
    cursor: "pointer",
  },
  secondaryButton: {
    padding: "10px 14px",
    borderRadius: 10,
    border: "1px solid rgba(255,255,255,0.2)",
    background: "transparent",
    color: "white",
    opacity: 0.85,
    cursor: "pointer",
  },
};
</file>

<file path="pages/store/index.jsx">
// pages/store/index.jsx
import { useEffect, useMemo, useState } from "react";
import {
  getCipherCoin,
  getLedger,
  rewardDaily,
  rewardEmailBonus,
  getUserEmail,
  hasEntitlement,
  purchaseStarterPack,
  getResetTokenCount,
  grantResetToken,
  devGrantCipherCoin,
} from "../../components/chat/CipherCoin";

export default function Store() {
  const [coinBalance, setCoinBalance] = useState(0);
  const [ledger, setLedger] = useState([]);
  const [toast, setToast] = useState(null);

  const [email, setEmail] = useState("");
  const [emailSaved, setEmailSaved] = useState(false);

  const [starterOwned, setStarterOwned] = useState(false);
  const [resetTokens, setResetTokens] = useState(0);

  function refreshAll() {
    setCoinBalance(getCipherCoin());
    setStarterOwned(hasEntitlement("starter_pack"));
    setResetTokens(getResetTokenCount());
    setLedger(getLedger(12));
  }

  useEffect(() => {
    if (typeof window === "undefined") return;

    const existing = getUserEmail();
    if (existing) {
      setEmail(existing);
      setEmailSaved(true);
    }

    refreshAll();
  }, []);

  useEffect(() => {
    if (!toast) return;
    const t = setTimeout(() => setToast(null), 2600);
    return () => clearTimeout(t);
  }, [toast]);

  function handleClaimDaily() {
    const r = rewardDaily();
    if (r.ok) {
      refreshAll();
      setToast(`ü™ô +${r.earned} Daily claimed`);
    } else {
      setToast("Daily already claimed. Come back tomorrow.");
    }
  }

  function handleSaveEmail() {
    const v = String(email || "").trim();
    if (!v) return setToast("Enter an email first.");

    const r = rewardEmailBonus(v);
    if (r.ok) {
      setEmailSaved(true);
      refreshAll();
      setToast(`ü™ô +${r.earned} Email bonus`);
    } else if (r.reason === "already_claimed") {
      setEmailSaved(true);
      setToast("Email saved");
    }
  }

  function handleBuyStarterPack() {
    const res = purchaseStarterPack();
    if (res.ok) {
      refreshAll();
      setToast("‚úÖ Starter Pack unlocked");
    } else if (res.reason === "already_owned") {
      setToast("Already owned.");
    } else {
      setToast("Not enough Cipher Coin.");
    }
  }

  function handleBuyResetToken() {
    const COST = 10;
    if (coinBalance < COST) return setToast("Not enough Cipher Coin.");
    grantResetToken(1);
    refreshAll();
    setToast("üß† +1 Decipher Reset Token");
  }

  const starterCost = 25;
  const resetCost = 10;

  const recentActivityText = useMemo(
    () => (!ledger.length ? "No activity yet." : null),
    [ledger]
  );

  return (
    <div style={styles.wrap}>
      <header style={styles.header}>
        <h1 style={styles.title}>Store</h1>
        <p style={styles.subtitle}>The Cipher economy lives here.</p>
      </header>

      <section style={styles.section}>
        <h2 style={styles.sectionTitle}>ü™ô Cipher Coin</h2>
        <div style={styles.card}>
          <div style={styles.coinRow}>
            <span style={styles.coinIcon}>ü™ô</span>
            <span style={styles.coinAmount}>{coinBalance}</span>
          </div>
          <p style={styles.text}>Cipher Coin is earned ‚Äî not bought.</p>
        </div>
      </section>

      <section style={styles.section}>
        <h2 style={styles.sectionTitle}>‚ö° Earn</h2>
        <div style={styles.card}>
          <button style={styles.primaryBtn} onClick={handleClaimDaily}>
            Claim Daily (+1)
          </button>

          <div style={{ height: 10 }} />

          <div style={styles.row}>
            <div style={{ flex: 1 }}>
              <div style={styles.textMuted}>Email Bonus (+5 once)</div>
              <input
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                placeholder="you@email.com"
                style={styles.input}
              />
            </div>
            <button style={styles.secondaryBtn} onClick={handleSaveEmail}>
              {emailSaved ? "Saved" : "Save"}
            </button>
          </div>
        </div>
      </section>

      <section style={styles.section}>
        <h2 style={styles.sectionTitle}>üõí Featured</h2>

        <div style={styles.card}>
          <div style={styles.itemHeader}>
            <div>
              <div style={styles.itemTitle}>Starter Pack</div>
              <div style={styles.itemDesc}>
                Reduce Decipher cooldown by 50%. Includes badge + early access.
              </div>
            </div>
            <div style={styles.pricePill}>ü™ô {starterCost}</div>
          </div>

          <div style={{ height: 10 }} />

          {starterOwned ? (
            <button style={styles.ownedBtn} disabled>‚úÖ Owned</button>
          ) : (
            <button
              style={styles.primaryBtn}
              onClick={handleBuyStarterPack}
              disabled={coinBalance < starterCost}
            >
              Unlock Starter Pack
            </button>
          )}
        </div>

        <div style={{ height: 14 }} />

        <div style={styles.card}>
          <div style={styles.itemHeader}>
            <div>
              <div style={styles.itemTitle}>Decipher Reset Token</div>
              <div style={styles.itemDesc}>Instantly reset Decipher cooldown.</div>
              <div style={styles.textMuted}>Owned: {resetTokens}</div>
            </div>
            <div style={styles.pricePill}>ü™ô {resetCost}</div>
          </div>

          <div style={{ height: 10 }} />

          <button
            style={styles.primaryBtn}
            onClick={handleBuyResetToken}
            disabled={coinBalance < resetCost}
          >
            Buy Reset Token
          </button>
        </div>
      </section>

      <section style={styles.section}>
        <h2 style={styles.sectionTitle}>üìú Recent Activity</h2>
        <div style={styles.card}>
          {recentActivityText ? (
            <p style={styles.textMuted}>{recentActivityText}</p>
          ) : (
            ledger.map((e, idx) => (
              <div key={idx} style={styles.ledgerRow}>
                <div>
                  <div style={styles.ledgerReason}>{e.reason}</div>
                  <div style={styles.ledgerMeta}>
                    {new Date(e.ts).toLocaleString()}
                  </div>
                </div>
                <div style={styles.ledgerAmt}>
                  {e.amount > 0 ? `+${e.amount}` : e.amount}
                </div>
              </div>
            ))
          )}
        </div>
      </section>

      {process.env.NODE_ENV !== "production" && (
        <section style={styles.section}>
          <h2 style={styles.sectionTitle}>üß™ Dev Tools</h2>
          <div style={styles.card}>
            <button
              style={styles.primaryBtn}
              onClick={() => {
                devGrantCipherCoin(1000);
                refreshAll();
                setToast("üß™ +1000 Cipher Coin");
              }}
            >
              Grant 1000 Cipher Coin
            </button>
          </div>
        </section>
      )}

      {toast && <div style={styles.toast}>{toast}</div>}
    </div>
  );
}

/* ===============================
   STYLES
================================ */
const styles = {
  wrap: {
    minHeight: "100vh",
    background: "linear-gradient(180deg,#05050b,#0a0f2a)",
    color: "white",
    padding: "24px 18px 60px",
    fontFamily: "system-ui",
  },
  header: { marginBottom: 28 },
  title: { fontSize: 32, fontWeight: 900 },
  subtitle: { opacity: 0.7, fontSize: 14 },
  section: { marginBottom: 26 },
  sectionTitle: { fontSize: 20, fontWeight: 800, marginBottom: 12 },
  card: {
    background: "rgba(255,255,255,0.04)",
    borderRadius: 16,
    padding: 16,
    border: "1px solid rgba(255,255,255,0.08)",
    boxShadow: "0 10px 30px rgba(0,0,0,0.25)",
  },
  coinRow: { display: "flex", gap: 10, fontSize: 24, fontWeight: 900 },
  coinIcon: { fontSize: 28 },
  coinAmount: { fontSize: 28 },
  text: { fontSize: 14 },
  textMuted: { fontSize: 13, opacity: 0.7 },
  row: { display: "flex", gap: 10, alignItems: "center" },
  input: {
    width: "100%",
    padding: 12,
    borderRadius: 12,
    background: "rgba(0,0,0,0.25)",
    color: "white",
    border: "1px solid rgba(255,255,255,0.1)",
  },
  primaryBtn: {
    width: "100%",
    padding: 12,
    borderRadius: 14,
    background: "linear-gradient(90deg,#6f7dff,#a06bff)",
    border: "none",
    color: "white",
    fontWeight: 900,
  },
  secondaryBtn: {
    padding: 12,
    borderRadius: 14,
    background: "rgba(255,255,255,0.05)",
    border: "1px solid rgba(255,255,255,0.12)",
    color: "white",
    fontWeight: 800,
  },
  ownedBtn: {
    width: "100%",
    padding: 12,
    borderRadius: 14,
    background: "rgba(255,255,255,0.06)",
    border: "1px solid rgba(255,255,255,0.18)",
    fontWeight: 900,
  },
  itemHeader: { display: "flex", justifyContent: "space-between", gap: 12 },
  itemTitle: { fontSize: 18, fontWeight: 900 },
  itemDesc: { fontSize: 13, opacity: 0.75 },
  pricePill: {
    padding: "6px 12px",
    borderRadius: 999,
    background: "rgba(255,255,255,0.08)",
    fontWeight: 800,
  },
  ledgerRow: {
    display: "flex",
    justifyContent: "space-between",
    padding: 10,
    borderRadius: 12,
    background: "rgba(255,255,255,0.03)",
    marginBottom: 8,
  },
  ledgerReason: { fontWeight: 800 },
  ledgerMeta: { fontSize: 11, opacity: 0.6 },
  ledgerAmt: { fontWeight: 900 },
  toast: {
    position: "fixed",
    bottom: 18,
    left: "50%",
    transform: "translateX(-50%)",
    padding: 12,
    borderRadius: 14,
    background: "rgba(10,10,20,0.95)",
    fontWeight: 800,
    zIndex: 9999,
  },
};
</file>

<file path="components/chat/InputBar.jsx">
// components/chat/InputBar.jsx
import { useRef } from "react";
import { styles } from "./ChatStyles";

export default function InputBar({
  input,
  setInput,
  onSend,
  typing,
}) {
  const holdTimer = useRef(null);
  const decipherArmed = useRef(false);
  const longPressTriggered = useRef(false);

  function startHold() {
    decipherArmed.current = false;
    longPressTriggered.current = false;

    holdTimer.current = setTimeout(() => {
      decipherArmed.current = true;
      longPressTriggered.current = true;

      // üì≥ haptic feedback
      if (navigator.vibrate) navigator.vibrate(15);
    }, 600);
  }

  function endHold() {
    clearTimeout(holdTimer.current);

    // üî• MOBILE: fire immediately on long-press release
    if (longPressTriggered.current && !typing) {
      onSend({ forceDecipher: true });
    }

    decipherArmed.current = false;
    longPressTriggered.current = false;
  }

  function handleClick() {
    // üñ± desktop / short tap
    if (typing) return;
    onSend({ forceDecipher: false });
  }

  return (
    <div style={styles.inputWrap}>
      <input
        style={styles.input}
        value={input}
        onChange={(e) => setInput(e.target.value)}
        placeholder="Talk to Cipher‚Ä¶"
        disabled={typing}
        onKeyDown={(e) => {
          if (e.key === "Enter") handleClick();
        }}
      />

      <button
        style={styles.sendBtn}
        disabled={typing}
        title="Hold to Decipher"
        onTouchStart={startHold}
        onTouchEnd={endHold}
        onMouseDown={startHold}
        onMouseUp={endHold}
        onMouseLeave={endHold}
        onClick={handleClick}
      >
        ‚û§
      </button>
    </div>
  );
}
</file>

<file path="components/chat/CipherCoin.js">
// components/chat/CipherCoin.js
// Single source of truth for Cipher Coin + rewards + ledger + store entitlements + consumables.

const COIN_KEY = "cipher_coin_balance";
const LEDGER_KEY = "cipher_coin_ledger";

// cooldown/claim keys
const LAST_SHARE_KEY = "cipher_last_share_reward";
const LAST_DAILY_KEY = "cipher_last_daily_reward";

// referral
const REF_CLAIMED_PREFIX = "cipher_ref_claimed_";
const REF_LAST_SEEN = "cipher_ref_last_seen";

// optional identity
const EMAIL_KEY = "cipher_user_email";

// store
const ENTITLEMENTS_KEY = "cipher_store_entitlements";
const CONSUMABLES_KEY = "cipher_store_consumables";

// ===== helpers =====
function safeParse(json, fallback) {
  try {
    const v = JSON.parse(json);
    return v ?? fallback;
  } catch {
    return fallback;
  }
}

function nowIso() {
  return new Date().toISOString();
}

function clampInt(n) {
  const x = Number(n);
  if (!Number.isFinite(x)) return 0;
  return Math.trunc(x);
}

function isBrowser() {
  return typeof window !== "undefined";
}

// ===== ledger =====
export function getLedger(limit = 50) {
  if (!isBrowser()) return [];
  const raw = localStorage.getItem(LEDGER_KEY);
  const arr = safeParse(raw, []);
  return Array.isArray(arr) ? arr.slice(0, limit) : [];
}

export function addLedgerEntry(entry) {
  if (!isBrowser()) return [];
  const current = getLedger(200);
  const next = [{ ...entry, ts: entry.ts || nowIso() }, ...current].slice(0, 200);
  localStorage.setItem(LEDGER_KEY, JSON.stringify(next));
  return next;
}

// ===== balance =====
export function getCipherCoin() {
  if (!isBrowser()) return 0;
  const raw = localStorage.getItem(COIN_KEY);
  return raw ? Number(raw) : 0;
}

export function setCipherCoin(next) {
  if (!isBrowser()) return 0;
  const n = Math.max(0, clampInt(next));
  localStorage.setItem(COIN_KEY, String(n));
  return n;
}

export function addCipherCoin(amount, reason = "unknown", meta = {}) {
  const current = getCipherCoin();
  const next = setCipherCoin(current + clampInt(amount));

  addLedgerEntry({
    type: "earn",
    reason,
    amount: clampInt(amount),
    balanceAfter: next,
    meta,
  });

  return next;
}

export function spendCipherCoin(amount, reason = "spend", meta = {}) {
  const amt = Math.max(0, clampInt(amount));
  const current = getCipherCoin();
  if (current < amt) return { ok: false, balance: current };

  const next = setCipherCoin(current - amt);

  addLedgerEntry({
    type: "spend",
    reason,
    amount: -amt,
    balanceAfter: next,
    meta,
  });

  return { ok: true, balance: next };
}

// ===== rewards =====
const DAY_MS = 24 * 60 * 60 * 1000;

export function rewardDaily() {
  if (!isBrowser()) return { ok: false };
  const last = localStorage.getItem(LAST_DAILY_KEY);
  if (last && Date.now() - Number(last) < DAY_MS) {
    return { ok: false, reason: "cooldown" };
  }

  localStorage.setItem(LAST_DAILY_KEY, String(Date.now()));
  const balance = addCipherCoin(1, "daily", { cooldown: "24h" });
  return { ok: true, earned: 1, balance };
}

export function rewardShare() {
  if (!isBrowser()) return { ok: false };
  const last = localStorage.getItem(LAST_SHARE_KEY);
  if (last && Date.now() - Number(last) < DAY_MS) {
    return { ok: false, reason: "cooldown" };
  }

  localStorage.setItem(LAST_SHARE_KEY, String(Date.now()));
  const balance = addCipherCoin(2, "share", { cooldown: "24h" });
  return { ok: true, earned: 2, balance };
}

// ===== referral =====
export function claimReferral(refCodeRaw) {
  if (!isBrowser()) return { ok: false };
  const refCode = String(refCodeRaw || "").trim();
  if (!refCode) return { ok: false };

  const claimedKey = `${REF_CLAIMED_PREFIX}${refCode}`;
  if (localStorage.getItem(claimedKey)) {
    return { ok: false, reason: "already_claimed" };
  }

  localStorage.setItem(REF_LAST_SEEN, refCode);
  localStorage.setItem(claimedKey, "true");

  const balance = addCipherCoin(3, "referral", { ref: refCode });
  return { ok: true, earned: 3, balance };
}

// ===== email bonus =====
const EMAIL_BONUS_KEY = "cipher_email_bonus_claimed";

export function getUserEmail() {
  if (!isBrowser()) return null;
  return localStorage.getItem(EMAIL_KEY) || null;
}

export function rewardEmailBonus(email) {
  if (!isBrowser()) return { ok: false };
  const v = String(email || "").trim();
  if (!v) return { ok: false };

  if (localStorage.getItem(EMAIL_BONUS_KEY)) {
    localStorage.setItem(EMAIL_KEY, v);
    return { ok: false, reason: "already_claimed" };
  }

  localStorage.setItem(EMAIL_KEY, v);
  localStorage.setItem(EMAIL_BONUS_KEY, "true");

  const balance = addCipherCoin(5, "email_bonus", { email: v });
  return { ok: true, earned: 5, balance };
}

// ==============================
// ENTITLEMENTS (PERMANENT)
// ==============================
export function getEntitlements() {
  if (!isBrowser()) return {};
  return safeParse(localStorage.getItem(ENTITLEMENTS_KEY), {});
}

export function hasEntitlement(key) {
  const ent = getEntitlements();
  return Boolean(ent && ent[key]);
}

export function purchaseStarterPack() {
  const ENT_KEY = "starter_pack";
  const COST = 25;

  if (!isBrowser()) return { ok: false, reason: "ssr" };
  if (hasEntitlement(ENT_KEY)) return { ok: false, reason: "already_owned" };

  const spend = spendCipherCoin(COST, "purchase", { item: ENT_KEY });
  if (!spend.ok) return { ok: false, reason: "insufficient_funds", balance: spend.balance };

  const ent = getEntitlements();
  localStorage.setItem(ENTITLEMENTS_KEY, JSON.stringify({ ...ent, [ENT_KEY]: true }));

  addLedgerEntry({
    type: "entitlement",
    reason: "unlock",
    amount: 0,
    balanceAfter: spend.balance,
    meta: { item: ENT_KEY },
  });

  return { ok: true, balance: spend.balance, cost: COST, item: ENT_KEY };
}

// ==============================
// CONSUMABLES (STACKABLE)
// ==============================
export function getConsumables() {
  if (!isBrowser()) return {};
  return safeParse(localStorage.getItem(CONSUMABLES_KEY), {});
}

function setConsumables(next) {
  if (!isBrowser()) return;
  localStorage.setItem(CONSUMABLES_KEY, JSON.stringify(next));
}

export function getResetTokenCount() {
  const cons = getConsumables();
  return clampInt(cons.decipher_reset || 0);
}

// Grants tokens without spending (admin/debug/internal)
export function grantResetToken(count = 1) {
  if (!isBrowser()) return 0;
  const cons = getConsumables();
  const next = {
    ...cons,
    decipher_reset: clampInt((cons.decipher_reset || 0) + clampInt(count)),
  };
  setConsumables(next);

  addLedgerEntry({
    type: "grant",
    reason: "decipher_reset_token",
    amount: clampInt(count),
    meta: { total: next.decipher_reset },
  });

  return next.decipher_reset;
}

// ‚úÖ Proper purchase function (spends coin + grants token)
export function purchaseResetToken(count = 1) {
  const COST_EACH = 10;
  const qty = Math.max(1, clampInt(count));
  const totalCost = COST_EACH * qty;

  if (!isBrowser()) return { ok: false, reason: "ssr" };

  const spend = spendCipherCoin(totalCost, "purchase", {
    item: "decipher_reset_token",
    qty,
    costEach: COST_EACH,
  });
  if (!spend.ok) return { ok: false, reason: "insufficient_funds", balance: spend.balance };

  const total = grantResetToken(qty);

  addLedgerEntry({
    type: "consumable_purchase",
    reason: "decipher_reset_token",
    amount: 0,
    balanceAfter: spend.balance,
    meta: { qty, total, cost: totalCost },
  });

  return { ok: true, balance: spend.balance, cost: totalCost, qty, total };
}

export function consumeResetToken() {
  if (!isBrowser()) return { ok: false, reason: "ssr" };
  const cons = getConsumables();
  const cur = clampInt(cons.decipher_reset || 0);
  if (cur <= 0) return { ok: false, reason: "none" };

  const next = { ...cons, decipher_reset: Math.max(0, cur - 1) };
  setConsumables(next);

  addLedgerEntry({
    type: "consume",
    reason: "decipher_reset_token",
    amount: 0,
    meta: { remaining: next.decipher_reset },
  });

  return { ok: true, remaining: next.decipher_reset };
}
// ==============================
// DEV FAUCET (REMOVE BEFORE LAUNCH)
// ==============================
export function devGrantCipherCoin(amount = 1000) {
  if (typeof window === "undefined") return 0;

  const next = addCipherCoin(amount, "dev_faucet", { dev: true });

  addLedgerEntry({
    type: "dev",
    reason: "faucet",
    amount,
    balanceAfter: next,
  });

  return next;
}
</file>

<file path="pages/api/chat.js">
// pages/api/chat.js
import { runCipherCore } from "../../cipher_core/core";
import { loadMemory, saveMemory } from "../../cipher_core/memory";

const OPENAI_URL = "https://api.openai.com/v1/chat/completions";

function asBool(v) {
  return String(v || "").toLowerCase() === "true";
}

function sanitizeHistory(history, limit = 12) {
  if (!Array.isArray(history)) return [];
  return history
    .slice(-limit)
    .map((m) => {
      const roleRaw = String(m?.role || "assistant");
      const role =
        roleRaw === "decipher"
          ? "assistant"
          : roleRaw === "user" || roleRaw === "assistant" || roleRaw === "system"
          ? roleRaw
          : "assistant";

      return { role, content: String(m?.content || "") };
    })
    .filter((m) => m.content.trim().length > 0);
}

export default async function handler(req, res) {
  res.setHeader("Cache-Control", "no-store");

  // Always return JSON (prevents "Empty response from API")
  try {
    if (req.method !== "POST") {
      return res.status(200).json({ reply: "Method not allowed." });
    }

    if (!process.env.OPENAI_API_KEY) {
      return res.status(200).json({
        reply: "Server misconfigured: OPENAI_API_KEY missing.",
      });
    }

    const body = req.body || {};
    const message = String(body.message || "").trim();
    const uiHistory = sanitizeHistory(body.history, 12);

    if (!message) {
      return res.status(200).json({ reply: "Say something real." });
    }

    // TEMP: single-user anchor
    const userId = "jim";

    // ---------- Phase 4 switches ----------
    // Kill switch: if false, CipherCore is ignored entirely.
    const CORE_ENABLED = asBool(process.env.CIPHER_CORE_ENABLED);

    // Memory write is optional; never allowed to break chat.
    const MEMORY_WRITE_ENABLED = asBool(process.env.CIPHER_MEMORY_WRITE_ENABLED);

    // ---------- Base prompt (Phase 3 safe default) ----------
    let systemPrompt = `
You are Cipher.

You are not a generic assistant.
You know the user is Jim.

Do NOT say you lack context.
Do NOT reintroduce yourself.
Speak naturally and directly.
Avoid generic therapy/coaching language.
Be grounded, specific, and helpful.

If you don't have enough info, ask one direct question.
    `.trim();

    // ---------- CipherCore (Phase 4: optional + non-blocking) ----------
    // CipherCore is allowed to ENHANCE the system prompt only.
    // If anything fails, we fall back to the base prompt and still answer.
    if (CORE_ENABLED) {
      try {
        const memoryData = await loadMemory(userId);
        const longTerm = Array.isArray(memoryData?.history)
          ? memoryData.history
          : [];

        // Keep it small; big payloads increase failures + cost
        const merged = [...longTerm, ...uiHistory].slice(-50);

        const enhanced = await runCipherCore(
          { history: merged },
          { userMessage: message }
        );

        if (enhanced && String(enhanced).trim().length > 0) {
          systemPrompt = String(enhanced).trim();
        }
      } catch (e) {
        console.error("CipherCore skipped (fallback to base):", e);
      }
    }

    const messages = [
      { role: "system", content: systemPrompt },
      ...uiHistory,
      { role: "user", content: message },
    ];

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 25000);

    let data = null;
    try {
      const model = process.env.OPENAI_MODEL || "gpt-4o-mini";

      const response = await fetch(OPENAI_URL, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
        },
        body: JSON.stringify({
          model,
          messages,
          temperature: 0.6,
          // keep this modest while stabilizing
          max_tokens: 500,
        }),
        signal: controller.signal,
      });

      data = await response.json().catch(() => null);
      clearTimeout(timeoutId);

      if (!response.ok) {
        const msg =
          data?.error?.message ||
          data?.message ||
          `OpenAI error (${response.status}).`;

        console.error("OPENAI ERROR STATUS:", response.status);
        console.error("OPENAI ERROR BODY:", data);

        return res.status(200).json({ reply: msg });
      }
    } catch (err) {
      clearTimeout(timeoutId);

      if (err?.name === "AbortError") {
        return res.status(200).json({ reply: "Timeout. Try again." });
      }

      console.error("CHAT API CRASH (OpenAI call):", err);
      return res.status(200).json({ reply: "Cipher slipped. Try again." });
    }

    const reply =
      data?.choices?.[0]?.message?.content?.trim() ||
      "‚Ä¶";

    // ---------- Optional memory write (never allowed to break chat) ----------
    if (MEMORY_WRITE_ENABLED) {
      try {
        await saveMemory(userId, {
          type: "interaction",
          role: "user",
          content: message,
          importance: "medium",
        });

        await saveMemory(userId, {
          type: "interaction",
          role: "assistant",
          content: reply,
          importance: "medium",
        });
      } catch (e) {
        console.error("Memory write skipped (non-fatal):", e);
      }
    }

    return res.status(200).json({ reply });
  } catch (err) {
    console.error("CHAT API HARD CRASH:", err);
    return res.status(200).json({ reply: "Recovered from crash." });
  }
}
</file>

<file path="components/chat/ChatPanel.js">
// components/chat/ChatPanel.js
import { useState, useRef, useEffect } from "react";
import { styles } from "./ChatStyles";
import HeaderMenu from "./HeaderMenu";
import DrawerMenu from "./DrawerMenu";
import MessageList from "./MessageList";
import InputBar from "./InputBar";
import CipherNote from "./CipherNote";
import RewardToast from "./RewardToast";

import {
  canUseDecipher,
  recordDecipherUse,
  DECIPHER_COOLDOWN_MESSAGE,
  formatRemaining,
} from "./decipherCooldown";

import { getCipherCoin, rewardShare } from "./CipherCoin";

/* ===============================
   CONFIG
================================ */
const MEMORY_KEY = "cipher_memory";
const MEMORY_LIMIT = 50;
const HISTORY_WINDOW = 12;

const SILENCE_THRESHOLD_MS = 30 * 60 * 1000;
const LAST_USER_MESSAGE_KEY = "cipher_last_user_message";
const NOTE_SHOWN_KEY = "cipher_note_shown";
const RETURN_FROM_NOTE_KEY = "cipher_return_from_note";

// Match your backend/OpenAI guardrails better than 15s
const API_TIMEOUT_MS = 25000;

// Keep logs readable on mobile
const MAX_ERROR_PREVIEW = 280;

/* ===============================
   NOTES
================================ */
const NOTE_VARIANTS = [
  "Hey ‚Äî welcome back.\n\nYou were gone for a bit.\nJust wanted to say hi.",
  "You stepped away for a while.\n\nNo rush.\nI‚Äôm still here.",
  "It‚Äôs been a minute.\n\nHope you‚Äôre okay.\nThought I‚Äôd leave a note.",
  "Hey.\n\nYou disappeared for a bit.\nJust checking in.",
  "You‚Äôve been quiet.\n\nNothing urgent.\nJust saying hello.",
  "Welcome back.\n\nI was wondering when you‚Äôd return.",
  "Hi.\n\nNo pressure.\nJust wanted to say I noticed you were gone.",
];

const RETURN_LINES = [
  "Hey.",
  "I‚Äôm here.",
  "Yeah?",
  "What‚Äôs up.",
  "Hey ‚Äî I‚Äôm still here.",
];

function getRandomNote() {
  return NOTE_VARIANTS[Math.floor(Math.random() * NOTE_VARIANTS.length)];
}

function clampText(s, max = MAX_ERROR_PREVIEW) {
  const str = String(s ?? "");
  if (str.length <= max) return str;
  return str.slice(0, max) + "‚Ä¶";
}

/**
 * Robust API reader:
 * - returns { ok, status, data, raw, contentType }
 * - never assumes JSON
 */
async function readApiResponse(res) {
  const status = res?.status ?? 0;
  const contentType = res?.headers?.get?.("content-type") || "";

  // Read body as text first (works even for non-JSON)
  let raw = "";
  try {
    raw = await res.text();
  } catch {
    raw = "";
  }

  // Try JSON parse if it looks like JSON or content-type suggests it
  let data = null;
  const looksJson =
    contentType.includes("application/json") ||
    (raw && raw.trim().startsWith("{")) ||
    (raw && raw.trim().startsWith("["));

  if (looksJson && raw) {
    try {
      data = JSON.parse(raw);
    } catch {
      data = null;
    }
  }

  return {
    ok: Boolean(res?.ok),
    status,
    contentType,
    raw,
    data,
  };
}

/* ===============================
   COMPONENT
================================ */
export default function ChatPanel() {
  const [messages, setMessages] = useState(() => {
    if (typeof window === "undefined") {
      return [{ role: "assistant", content: "Cipher online." }];
    }

    try {
      const saved = localStorage.getItem(MEMORY_KEY);
      const parsed = saved ? JSON.parse(saved) : null;

      return Array.isArray(parsed) && parsed.length
        ? parsed.slice(-MEMORY_LIMIT)
        : [{ role: "assistant", content: "Cipher online." }];
    } catch {
      return [{ role: "assistant", content: "Cipher online." }];
    }
  });

  const [input, setInput] = useState("");
  const [typing, setTyping] = useState(false);
  const [cipherNote, setCipherNote] = useState(null);

  const [drawerOpen, setDrawerOpen] = useState(false);
  const [coinBalance, setCoinBalance] = useState(0);
  const [toast, setToast] = useState(null);

  const bottomRef = useRef(null);
  const sendingRef = useRef(false);

  /* ===============================
     EFFECTS
  ================================ */
  useEffect(() => {
    bottomRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages, typing]);

  useEffect(() => {
    if (typeof window === "undefined") return;
    localStorage.setItem(MEMORY_KEY, JSON.stringify(messages.slice(-MEMORY_LIMIT)));
  }, [messages]);

  useEffect(() => {
    if (!drawerOpen) return;
    setCoinBalance(getCipherCoin());
  }, [drawerOpen]);

  useEffect(() => {
    if (typeof window === "undefined") return;

    const lastMessage = localStorage.getItem(LAST_USER_MESSAGE_KEY);
    const noteShown = sessionStorage.getItem(NOTE_SHOWN_KEY);
    if (!lastMessage || noteShown) return;

    if (Date.now() - Number(lastMessage) >= SILENCE_THRESHOLD_MS) {
      setCipherNote({ message: getRandomNote() });
      sessionStorage.setItem(NOTE_SHOWN_KEY, "true");
    }
  }, []);

  useEffect(() => {
    if (!sessionStorage.getItem(RETURN_FROM_NOTE_KEY)) return;

    setMessages((m) => [
      ...m,
      {
        role: "assistant",
        content: RETURN_LINES[Math.floor(Math.random() * RETURN_LINES.length)],
      },
    ]);

    sessionStorage.removeItem(RETURN_FROM_NOTE_KEY);
  }, []);

  /* ===============================
     INVITE / SHARE
  ================================ */
  async function handleInvite() {
    const url = `${window.location.origin}?ref=cipher`;

    try {
      if (navigator.share) {
        await navigator.share({
          title: "Cipher",
          text: "Try Cipher ‚Äî an AI that actually remembers.",
          url,
        });
      } else {
        await navigator.clipboard.writeText(url);
        setToast("üîó Link copied ‚Äî share it anywhere");
      }

      const rewarded = rewardShare();
      if (rewarded?.ok) {
        setCoinBalance(getCipherCoin());
        setToast(`ü™ô +${rewarded.earned} Cipher Coin earned`);
      }
    } catch {
      // user cancelled share
    }
  }

  /* ===============================
     SEND MESSAGE ‚Äî STABLE + TRUTHFUL ERRORS
  ================================ */
  async function sendMessage({ forceDecipher = false } = {}) {
    if (sendingRef.current) return;
    if (!input.trim()) return;

    sendingRef.current = true;
    setTyping(true);

    let activeMode = forceDecipher ? "decipher" : "cipher";

    // üßä SOFT DECIPHER COOLDOWN (NEVER BLOCK UI)
    if (activeMode === "decipher") {
      const gate = canUseDecipher();
      if (!gate.allowed) {
        setMessages((m) => [
          ...m,
          {
            role: "assistant",
            content: `${DECIPHER_COOLDOWN_MESSAGE}\n‚è≥ ${formatRemaining(
              gate.remainingMs
            )}`,
          },
        ]);
        setTyping(false);
        sendingRef.current = false;
        return;
      }
    }

    const userMessage = { role: "user", content: input };
    const historySnapshot = [...messages, userMessage];

    localStorage.setItem(LAST_USER_MESSAGE_KEY, String(Date.now()));
    setMessages(historySnapshot);
    setInput("");

    try {
      const endpoint = activeMode === "decipher" ? "/api/decipher" : "/api/chat";

      const payload =
        activeMode === "decipher"
          ? {
              message: userMessage.content,
              context: historySnapshot.slice(-HISTORY_WINDOW),
            }
          : {
              message: userMessage.content,
              history: historySnapshot.slice(-HISTORY_WINDOW),
            };

      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), API_TIMEOUT_MS);

      const res = await fetch(endpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
        signal: controller.signal,
      });

      clearTimeout(timeout);

      const parsed = await readApiResponse(res);

      // If server returned error, show what it actually said
      if (!parsed.ok) {
        const serverMsg =
          parsed?.data?.reply ||
          parsed?.data?.error ||
          parsed?.data?.message ||
          (parsed.raw ? clampText(parsed.raw) : "");

        throw new Error(
          serverMsg
            ? `API ${parsed.status}: ${serverMsg}`
            : `API ${parsed.status}: (no body)`
        );
      }

      // Prefer JSON reply, fall back to raw if server responded weirdly
      const reply =
        parsed?.data?.reply ||
        parsed?.data?.message ||
        (parsed.raw ? parsed.raw.trim() : "");

      if (!reply) {
        // This is the real case you keep hitting ‚Äî show status + content-type
        throw new Error(
          `API ${parsed.status}: empty body (content-type: ${parsed.contentType || "unknown"})`
        );
      }

      if (activeMode === "decipher") {
        recordDecipherUse();
      }

      setMessages((m) => [
        ...m,
        {
          role: activeMode === "decipher" ? "decipher" : "assistant",
          content: String(reply ?? "‚Ä¶"),
        },
      ]);
    } catch (err) {
      console.error("Cipher send failed:", err);

      const msg =
        err?.name === "AbortError"
          ? `Timeout after ${Math.round(API_TIMEOUT_MS / 1000)}s. (Likely OpenAI/DB delay)`
          : clampText(err?.message || "Unknown transport error");

      setMessages((m) => [
        ...m,
        {
          role: "assistant",
          content: `Transport error: ${msg}`,
        },
      ]);
    } finally {
      setTyping(false);
      sendingRef.current = false;
    }
  }

  /* ===============================
     RENDER
  ================================ */
  return (
    <div style={styles.wrap}>
      {cipherNote && (
        <CipherNote
          note={cipherNote}
          onOpen={() => {
            sessionStorage.setItem(RETURN_FROM_NOTE_KEY, "true");
            setCipherNote(null);
          }}
          onDismiss={() => setCipherNote(null)}
        />
      )}

      <HeaderMenu title="CIPHER" onOpenDrawer={() => setDrawerOpen(true)} />

      <DrawerMenu
        open={drawerOpen}
        onClose={() => setDrawerOpen(false)}
        cipherCoin={coinBalance}
        onInvite={handleInvite}
        onOpenStore={() => (window.location.href = "/store")}
      />

      <div style={styles.chat}>
        <MessageList messages={messages} bottomRef={bottomRef} />
      </div>

      <InputBar input={input} setInput={setInput} onSend={sendMessage} typing={typing} />

      {toast && <RewardToast message={toast} onClose={() => setToast(null)} />}
    </div>
  );
}
</file>

</files>
